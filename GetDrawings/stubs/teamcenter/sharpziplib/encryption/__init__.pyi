# This file is auto-generated by generate_tc_stubs.py
# Type hints only â€“ improves VS Code/Pylance & Codex suggestions.
from __future__ import annotations
import typing
import enum
# stub package
from teamcenter.icsharpcode.sharpziplib.encryption import PkzipClassic
from teamcenter.icsharpcode.sharpziplib.encryption import PkzipClassicCryptoBase
from teamcenter.system.security.cryptography import CryptoStream
from teamcenter.system.security.cryptography import HMACSHA1
from teamcenter.system.security.cryptography import SymmetricAlgorithm

class HashAlgorithmName:
    """Stub for ICSharpCode.SharpZipLib.Encryption.ZipAESTransform+HashAlgorithmName"""
    def __init__(self) -> None: ...
    SHA1: typing.ClassVar[str]

class IncrementalHash(HMACSHA1):
    """Stub for ICSharpCode.SharpZipLib.Encryption.ZipAESTransform+IncrementalHash"""
    def __init__(self, key: typing.Sequence[int]) -> None: ...
    def AppendData(self, buffer: typing.Sequence[int], offset: int, count: int) -> None: ...
    @classmethod
    def CreateHMAC(cls, n: str, key: typing.Sequence[int]) -> typing.Any: ...
    def GetHashAndReset(self) -> typing.Sequence[int]: ...

class PkzipClassic(SymmetricAlgorithm):
    """Stub for ICSharpCode.SharpZipLib.Encryption.PkzipClassic"""
    def __init__(self) -> None: ...
    @classmethod
    def GenerateKeys(cls, seed: typing.Sequence[int]) -> typing.Sequence[int]: ...

class PkzipClassicCryptoBase:
    """Stub for ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase"""
    def __init__(self) -> None: ...

class PkzipClassicDecryptCryptoTransform(PkzipClassicCryptoBase):
    """Stub for ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform"""
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    def Dispose(self) -> None: ...
    def TransformBlock(self, inputBuffer: typing.Sequence[int], inputOffset: int, inputCount: int, outputBuffer: typing.Sequence[int], outputOffset: int) -> int: ...
    def TransformFinalBlock(self, inputBuffer: typing.Sequence[int], inputOffset: int, inputCount: int) -> typing.Sequence[int]: ...

class PkzipClassicEncryptCryptoTransform(PkzipClassicCryptoBase):
    """Stub for ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform"""
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    def Dispose(self) -> None: ...
    def TransformBlock(self, inputBuffer: typing.Sequence[int], inputOffset: int, inputCount: int, outputBuffer: typing.Sequence[int], outputOffset: int) -> int: ...
    def TransformFinalBlock(self, inputBuffer: typing.Sequence[int], inputOffset: int, inputCount: int) -> typing.Sequence[int]: ...

class PkzipClassicManaged(PkzipClassic):
    """Stub for ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged"""
    def __init__(self) -> None: ...
    @property
    def BlockSize(self) -> int: ...
    @property
    def LegalKeySizes(self) -> typing.Sequence[typing.Any]: ...
    @property
    def LegalBlockSizes(self) -> typing.Sequence[typing.Any]: ...
    @property
    def Key(self) -> typing.Sequence[int]: ...
    def CreateDecryptor(self, rgbKey: typing.Sequence[int], rgbIV: typing.Sequence[int]) -> typing.Any: ...
    def CreateEncryptor(self, rgbKey: typing.Sequence[int], rgbIV: typing.Sequence[int]) -> typing.Any: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...

class ZipAESStream(CryptoStream):
    """Stub for ICSharpCode.SharpZipLib.Encryption.ZipAESStream"""
    def __init__(self, stream: typing.Any, transform: typing.Any, mode: int) -> None: ...
    def Read(self, buffer: typing.Sequence[int], offset: int, count: int) -> int: ...
    def ReadAsync(self, buffer: typing.Sequence[int], offset: int, count: int, cancellationToken: typing.Any) -> typing.Awaitable[int]: ...
    def Write(self, buffer: typing.Sequence[int], offset: int, count: int) -> None: ...

class ZipAESTransform:
    """Stub for ICSharpCode.SharpZipLib.Encryption.ZipAESTransform"""
    def __init__(self, key: str, saltBytes: typing.Sequence[int], blockSize: int, writeMode: bool) -> None: ...
    @property
    def PwdVerifier(self) -> typing.Sequence[int]: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    def Dispose(self) -> None: ...
    def GetAuthCode(self) -> typing.Sequence[int]: ...
    def TransformBlock(self, inputBuffer: typing.Sequence[int], inputOffset: int, inputCount: int, outputBuffer: typing.Sequence[int], outputOffset: int) -> int: ...
    def TransformFinalBlock(self, inputBuffer: typing.Sequence[int], inputOffset: int, inputCount: int) -> typing.Sequence[int]: ...

__all__ = [
    'HashAlgorithmName',
    'IncrementalHash',
    'PkzipClassic',
    'PkzipClassicCryptoBase',
    'PkzipClassicDecryptCryptoTransform',
    'PkzipClassicEncryptCryptoTransform',
    'PkzipClassicManaged',
    'ZipAESStream',
    'ZipAESTransform',
]
