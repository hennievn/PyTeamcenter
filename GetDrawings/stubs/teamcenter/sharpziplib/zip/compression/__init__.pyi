# This file is auto-generated by generate_tc_stubs.py
# Type hints only â€“ improves VS Code/Pylance & Codex suggestions.
from __future__ import annotations
import typing
import enum
# stub package
from teamcenter.icsharpcode.sharpziplib.zip.compression import PendingBuffer

class CompressionLevel(enum.IntEnum):
    BEST_COMPRESSION: int = 9
    BEST_SPEED: int = 1
    DEFAULT_COMPRESSION: int = -1
    NO_COMPRESSION: int = 0
    DEFLATED: int = 8

class DeflateStrategy(enum.IntEnum):
    Default: int = 0
    Filtered: int = 1
    HuffmanOnly: int = 2

class Deflater:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.Deflater"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, level: int) -> None: ...
    @typing.overload
    def __init__(self, level: int, noZlibHeaderOrFooter: bool) -> None: ...
    @property
    def Adler(self) -> int: ...
    @property
    def TotalIn(self) -> int: ...
    @property
    def TotalOut(self) -> int: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def IsNeedingInput(self) -> bool: ...
    BEST_COMPRESSION: typing.ClassVar[int]
    BEST_SPEED: typing.ClassVar[int]
    DEFAULT_COMPRESSION: typing.ClassVar[int]
    NO_COMPRESSION: typing.ClassVar[int]
    DEFLATED: typing.ClassVar[int]
    @typing.overload
    def Deflate(self, output: typing.Sequence[int]) -> int: ...
    @typing.overload
    def Deflate(self, output: typing.Sequence[int], offset: int, length: int) -> int: ...
    def Finish(self) -> None: ...
    def Flush(self) -> None: ...
    def GetLevel(self) -> int: ...
    def Reset(self) -> None: ...
    @typing.overload
    def SetDictionary(self, dictionary: typing.Sequence[int]) -> None: ...
    @typing.overload
    def SetDictionary(self, dictionary: typing.Sequence[int], index: int, count: int) -> None: ...
    @typing.overload
    def SetInput(self, input: typing.Sequence[int]) -> None: ...
    @typing.overload
    def SetInput(self, input: typing.Sequence[int], offset: int, count: int) -> None: ...
    def SetLevel(self, level: int) -> None: ...
    def SetStrategy(self, strategy: int) -> None: ...

class DeflaterConstants:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants"""
    def __init__(self) -> None: ...
    MAX_BLOCK_SIZE: typing.ClassVar[int]
    GOOD_LENGTH: typing.ClassVar[typing.Sequence[int]]
    MAX_LAZY: typing.ClassVar[typing.Sequence[int]]
    NICE_LENGTH: typing.ClassVar[typing.Sequence[int]]
    MAX_CHAIN: typing.ClassVar[typing.Sequence[int]]
    COMPR_FUNC: typing.ClassVar[typing.Sequence[int]]
    DEBUGGING: typing.ClassVar[bool]
    STORED_BLOCK: typing.ClassVar[int]
    STATIC_TREES: typing.ClassVar[int]
    DYN_TREES: typing.ClassVar[int]
    PRESET_DICT: typing.ClassVar[int]
    DEFAULT_MEM_LEVEL: typing.ClassVar[int]
    MAX_MATCH: typing.ClassVar[int]
    MIN_MATCH: typing.ClassVar[int]
    MAX_WBITS: typing.ClassVar[int]
    WSIZE: typing.ClassVar[int]
    WMASK: typing.ClassVar[int]
    HASH_BITS: typing.ClassVar[int]
    HASH_SIZE: typing.ClassVar[int]
    HASH_MASK: typing.ClassVar[int]
    HASH_SHIFT: typing.ClassVar[int]
    MIN_LOOKAHEAD: typing.ClassVar[int]
    MAX_DIST: typing.ClassVar[int]
    PENDING_BUF_SIZE: typing.ClassVar[int]
    DEFLATE_STORED: typing.ClassVar[int]
    DEFLATE_FAST: typing.ClassVar[int]
    DEFLATE_SLOW: typing.ClassVar[int]

class DeflaterEngine:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine"""
    @typing.overload
    def __init__(self, pending: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, pending: typing.Any, noAdlerCalculation: bool) -> None: ...
    @property
    def Adler(self) -> int: ...
    @property
    def TotalIn(self) -> int: ...
    @property
    def Strategy(self) -> int: ...
    def Deflate(self, flush: bool, finish: bool) -> bool: ...
    def FillWindow(self) -> None: ...
    def NeedsInput(self) -> bool: ...
    def Reset(self) -> None: ...
    def ResetAdler(self) -> None: ...
    def SetDictionary(self, buffer: typing.Sequence[int], offset: int, length: int) -> None: ...
    def SetInput(self, buffer: typing.Sequence[int], offset: int, count: int) -> None: ...
    def SetLevel(self, level: int) -> None: ...

class DeflaterHuffman:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman"""
    def __init__(self, pending: typing.Any) -> None: ...
    pending: typing.Any
    @classmethod
    def BitReverse(cls, toReverse: int) -> int: ...
    def CompressBlock(self) -> None: ...
    def FlushBlock(self, stored: typing.Sequence[int], storedOffset: int, storedLength: int, lastBlock: bool) -> None: ...
    def FlushStoredBlock(self, stored: typing.Sequence[int], storedOffset: int, storedLength: int, lastBlock: bool) -> None: ...
    def IsFull(self) -> bool: ...
    def Reset(self) -> None: ...
    def SendAllTrees(self, blTreeCodes: int) -> None: ...
    def TallyDist(self, distance: int, length: int) -> bool: ...
    def TallyLit(self, literal: int) -> bool: ...

class DeflaterPending(PendingBuffer):
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending"""
    def __init__(self) -> None: ...

class Inflater:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.Inflater"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, noHeader: bool) -> None: ...
    @property
    def IsNeedingInput(self) -> bool: ...
    @property
    def IsNeedingDictionary(self) -> bool: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def Adler(self) -> int: ...
    @property
    def TotalOut(self) -> int: ...
    @property
    def TotalIn(self) -> int: ...
    @property
    def RemainingInput(self) -> int: ...
    @typing.overload
    def Inflate(self, buffer: typing.Sequence[int]) -> int: ...
    @typing.overload
    def Inflate(self, buffer: typing.Sequence[int], offset: int, count: int) -> int: ...
    def Reset(self) -> None: ...
    @typing.overload
    def SetDictionary(self, buffer: typing.Sequence[int]) -> None: ...
    @typing.overload
    def SetDictionary(self, buffer: typing.Sequence[int], index: int, count: int) -> None: ...
    @typing.overload
    def SetInput(self, buffer: typing.Sequence[int]) -> None: ...
    @typing.overload
    def SetInput(self, buffer: typing.Sequence[int], index: int, count: int) -> None: ...

class InflaterDynHeader:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.InflaterDynHeader"""
    def __init__(self, input: typing.Any) -> None: ...
    @property
    def LiteralLengthTree(self) -> typing.Any: ...
    @property
    def DistanceTree(self) -> typing.Any: ...
    def AttemptRead(self) -> bool: ...

class InflaterHuffmanTree:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree"""
    def __init__(self, codeLengths: typing.Sequence[int]) -> None: ...
    defLitLenTree: typing.ClassVar[typing.Any]
    defDistTree: typing.ClassVar[typing.Any]
    def GetSymbol(self, input: typing.Any) -> int: ...

class PendingBuffer:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, bufferSize: int) -> None: ...
    @property
    def BitCount(self) -> int: ...
    @property
    def IsFlushed(self) -> bool: ...
    def AlignToByte(self) -> None: ...
    def Flush(self, output: typing.Sequence[int], offset: int, length: int) -> int: ...
    def Reset(self) -> None: ...
    def ToByteArray(self) -> typing.Sequence[int]: ...
    def WriteBits(self, b: int, count: int) -> None: ...
    def WriteBlock(self, block: typing.Sequence[int], offset: int, length: int) -> None: ...
    def WriteByte(self, value: int) -> None: ...
    def WriteInt(self, value: int) -> None: ...
    def WriteShort(self, value: int) -> None: ...
    def WriteShortMSB(self, s: int) -> None: ...

class Tree:
    """Stub for ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman+Tree"""
    def __init__(self, dh: typing.Any, elems: int, minCodes: int, maxLength: int) -> None: ...
    freqs: typing.Sequence[int]
    length: typing.Sequence[int]
    minNumCodes: int
    numCodes: int
    def BuildCodes(self) -> None: ...
    def BuildTree(self) -> None: ...
    def CalcBLFreq(self, blTree: typing.Any) -> None: ...
    def CheckEmpty(self) -> None: ...
    def GetEncodedLength(self) -> int: ...
    def Reset(self) -> None: ...
    def SetStaticCodes(self, staticCodes: typing.Sequence[int], staticLengths: typing.Sequence[int]) -> None: ...
    def WriteSymbol(self, code: int) -> None: ...
    def WriteTree(self, blTree: typing.Any) -> None: ...

__all__ = [
    'CompressionLevel',
    'DeflateStrategy',
    'Deflater',
    'DeflaterConstants',
    'DeflaterEngine',
    'DeflaterHuffman',
    'DeflaterPending',
    'Inflater',
    'InflaterDynHeader',
    'InflaterHuffmanTree',
    'PendingBuffer',
    'Tree',
    'streams',
]
