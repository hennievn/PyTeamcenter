# This file is auto-generated by generate_tc_stubs.py
# Type hints only â€“ improves VS Code/Pylance & Codex suggestions.
from __future__ import annotations
import typing
import enum
# stub package
from teamcenter.newtonsoft.json.utilities import ReflectionDelegateFactory
from teamcenter.system import MulticastDelegate
from teamcenter.system import ValueType
from teamcenter.system.dynamic import GetMemberBinder
from teamcenter.system.dynamic import SetMemberBinder
from teamcenter.system.linq.expressions import ExpressionVisitor

class AsyncUtils:
    """Stub for Newtonsoft.Json.Utilities.AsyncUtils"""
    def __init__(self) -> None: ...
    False_: typing.ClassVar[typing.Awaitable[bool]]
    True_: typing.ClassVar[typing.Awaitable[bool]]
    @typing.overload
    @classmethod
    def CancelIfRequestedAsync(cls, cancellationToken: typing.Any) -> typing.Awaitable[None]: ...
    @typing.overload
    @classmethod
    def CancelIfRequestedAsync(cls, cancellationToken: typing.Any) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def FromCanceled(cls, cancellationToken: typing.Any) -> typing.Awaitable[None]: ...
    @typing.overload
    @classmethod
    def FromCanceled(cls, cancellationToken: typing.Any) -> typing.Awaitable[typing.Any]: ...
    @classmethod
    def IsCompletedSucessfully(cls, task: typing.Awaitable[None]) -> bool: ...
    @classmethod
    def ReadAsync(cls, reader: typing.Any, buffer: typing.Sequence[str], index: int, count: int, cancellationToken: typing.Any) -> typing.Awaitable[int]: ...
    @typing.overload
    @classmethod
    def WriteAsync(cls, writer: typing.Any, value: str, cancellationToken: typing.Any) -> typing.Awaitable[None]: ...
    @typing.overload
    @classmethod
    def WriteAsync(cls, writer: typing.Any, value: str, cancellationToken: typing.Any) -> typing.Awaitable[None]: ...
    @typing.overload
    @classmethod
    def WriteAsync(cls, writer: typing.Any, value: typing.Sequence[str], start: int, count: int, cancellationToken: typing.Any) -> typing.Awaitable[None]: ...

class Base64Encoder:
    """Stub for Newtonsoft.Json.Utilities.Base64Encoder"""
    def __init__(self, writer: typing.Any) -> None: ...
    def Encode(self, buffer: typing.Sequence[int], index: int, count: int) -> None: ...
    def EncodeAsync(self, buffer: typing.Sequence[int], index: int, count: int, cancellationToken: typing.Any) -> typing.Awaitable[None]: ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: typing.Any) -> typing.Awaitable[None]: ...

class BinderWrapper:
    """Stub for Newtonsoft.Json.Utilities.DynamicUtils+BinderWrapper"""
    def __init__(self) -> None: ...
    CSharpAssemblyName: typing.ClassVar[str]
    @classmethod
    def GetMember(cls, name: str, context: typing.Any) -> typing.Any: ...
    @classmethod
    def SetMember(cls, name: str, context: typing.Any) -> typing.Any: ...

class BufferUtils:
    """Stub for Newtonsoft.Json.Utilities.BufferUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def EnsureBufferSize(cls, bufferPool: typing.Any, size: int, buffer: typing.Sequence[str]) -> typing.Sequence[str]: ...
    @classmethod
    def RentBuffer(cls, bufferPool: typing.Any, minSize: int) -> typing.Sequence[str]: ...
    @classmethod
    def ReturnBuffer(cls, bufferPool: typing.Any, buffer: typing.Sequence[str]) -> None: ...

class ByRefParameter:
    """Stub for Newtonsoft.Json.Utilities.ExpressionReflectionDelegateFactory+ByRefParameter"""
    def __init__(self, value: typing.Any, variable: typing.Any, isOut: bool) -> None: ...
    Value: typing.Any
    Variable: typing.Any
    IsOut: bool

class CollectionUtils:
    """Stub for Newtonsoft.Json.Utilities.CollectionUtils"""
    def __init__(self) -> None: ...
    @typing.overload
    @classmethod
    def AddDistinct(cls, list: typing.Sequence[typing.Any], value: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def AddDistinct(cls, list: typing.Sequence[typing.Any], value: typing.Any, comparer: typing.Any) -> bool: ...
    @classmethod
    def AddRange(cls, initial: typing.Sequence[typing.Any], collection: typing.Iterable[typing.Any]) -> None: ...
    @classmethod
    def AddRangeDistinct(cls, list: typing.Sequence[typing.Any], values: typing.Iterable[typing.Any], comparer: typing.Any) -> bool: ...
    @classmethod
    def ArrayEmpty(cls) -> typing.Sequence[typing.Any]: ...
    @classmethod
    def Contains(cls, list: list[typing.Any], value: typing.Any, comparer: typing.Any) -> bool: ...
    @classmethod
    def ContainsValue(cls, source: typing.Iterable[typing.Any], value: typing.Any, comparer: typing.Any) -> bool: ...
    @classmethod
    def FastReverse(cls, list: list[typing.Any]) -> None: ...
    @classmethod
    def IndexOf(cls, collection: typing.Iterable[typing.Any], predicate: typing.Any) -> int: ...
    @classmethod
    def IndexOfReference(cls, list: list[typing.Any], item: typing.Any) -> int: ...
    @classmethod
    def IsDictionaryType(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsNullOrEmpty(cls, collection: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def ResolveEnumerableCollectionConstructor(cls, collectionType: typing.Any, collectionItemType: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def ResolveEnumerableCollectionConstructor(cls, collectionType: typing.Any, collectionItemType: typing.Any, constructorArgumentType: typing.Any) -> typing.Any: ...
    @classmethod
    def ToMultidimensionalArray(cls, values: typing.Any, type: typing.Any, rank: int) -> typing.Any: ...

class ConvertResult(enum.IntEnum):
    Success: int = 0
    CannotConvertNull: int = 1
    NotInstantiableType: int = 2
    NoValidConversion: int = 3

class ConvertUtils:
    """Stub for Newtonsoft.Json.Utilities.ConvertUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def Convert(cls, initialValue: typing.Any, culture: typing.Any, targetType: typing.Any) -> typing.Any: ...
    @classmethod
    def ConvertOrCast(cls, initialValue: typing.Any, culture: typing.Any, targetType: typing.Any) -> typing.Any: ...
    @classmethod
    def DecimalTryParse(cls, chars: typing.Sequence[str], start: int, length: int, value: typing.Any) -> int: ...
    @classmethod
    def FromBigInteger(cls, i: typing.Any, targetType: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def GetTypeCode(cls, t: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def GetTypeCode(cls, t: typing.Any, isEnum: typing.Any) -> int: ...
    @classmethod
    def GetTypeInformation(cls, convertable: typing.Any) -> typing.Any: ...
    @classmethod
    def Int32TryParse(cls, chars: typing.Sequence[str], start: int, length: int, value: typing.Any) -> int: ...
    @classmethod
    def Int64TryParse(cls, chars: typing.Sequence[str], start: int, length: int, value: typing.Any) -> int: ...
    @classmethod
    def IsConvertible(cls, t: typing.Any) -> bool: ...
    @classmethod
    def IsInteger(cls, value: typing.Any) -> bool: ...
    @classmethod
    def ParseTimeSpan(cls, input: str) -> typing.Any: ...
    @classmethod
    def TryConvertGuid(cls, s: str, g: typing.Any) -> bool: ...
    @classmethod
    def TryHexTextToInt(cls, text: typing.Sequence[str], start: int, end: int, value: typing.Any) -> bool: ...
    @classmethod
    def VersionTryParse(cls, input: str, result: typing.Any) -> bool: ...

class DateTimeParser(ValueType):
    """Stub for Newtonsoft.Json.Utilities.DateTimeParser"""
    def __init__(self) -> None: ...
    Year: int
    Month: int
    Day: int
    Hour: int
    Minute: int
    Second: int
    Fraction: int
    ZoneHour: int
    ZoneMinute: int
    Zone: int
    def Parse(self, text: typing.Sequence[str], startIndex: int, length: int) -> bool: ...

class DateTimeUtils:
    """Stub for Newtonsoft.Json.Utilities.DateTimeUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def GetUtcOffset(cls, d: typing.Any) -> typing.Any: ...
    @classmethod
    def ToSerializationMode(cls, kind: int) -> int: ...

class DynamicReflectionDelegateFactory(ReflectionDelegateFactory):
    """Stub for Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory"""
    def __init__(self) -> None: ...
    def CreateDefaultConstructor(self, type: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, propertyInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, fieldInfo: typing.Any) -> typing.Any: ...
    def CreateMethodCall(self, method: typing.Any) -> typing.Any: ...
    def CreateParameterizedConstructor(self, method: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, fieldInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, propertyInfo: typing.Any) -> typing.Any: ...

class DynamicUtils:
    """Stub for Newtonsoft.Json.Utilities.DynamicUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def GetDynamicMemberNames(cls, dynamicProvider: typing.Any) -> typing.Iterable[str]: ...

class EnumInfo:
    """Stub for Newtonsoft.Json.Utilities.EnumInfo"""
    def __init__(self, isFlags: bool, values: typing.Sequence[int], names: typing.Sequence[str], resolvedNames: typing.Sequence[str]) -> None: ...
    IsFlags: bool
    Values: typing.Sequence[int]
    Names: typing.Sequence[str]
    ResolvedNames: typing.Sequence[str]

class EnumUtils:
    """Stub for Newtonsoft.Json.Utilities.EnumUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def GetEnumValuesAndNames(cls, enumType: typing.Any) -> typing.Any: ...
    @classmethod
    def GetFlagsValues(cls, value: typing.Any) -> typing.Sequence[typing.Any]: ...
    @classmethod
    def ParseEnum(cls, enumType: typing.Any, namingStrategy: typing.Any, value: str, disallowNumber: bool) -> typing.Any: ...
    @typing.overload
    @classmethod
    def TryToString(cls, enumType: typing.Any, value: typing.Any, camelCase: bool, name: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def TryToString(cls, enumType: typing.Any, value: typing.Any, namingStrategy: typing.Any, name: typing.Any) -> bool: ...

class ExpressionReflectionDelegateFactory(ReflectionDelegateFactory):
    """Stub for Newtonsoft.Json.Utilities.ExpressionReflectionDelegateFactory"""
    def __init__(self) -> None: ...
    def CreateDefaultConstructor(self, type: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, propertyInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, fieldInfo: typing.Any) -> typing.Any: ...
    def CreateMethodCall(self, method: typing.Any) -> typing.Any: ...
    def CreateParameterizedConstructor(self, method: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, fieldInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, propertyInfo: typing.Any) -> typing.Any: ...

class FSharpFunction:
    """Stub for Newtonsoft.Json.Utilities.FSharpFunction"""
    def __init__(self, instance: typing.Any, invoker: typing.Any) -> None: ...
    def Invoke(self, args: typing.Sequence[typing.Any]) -> typing.Any: ...

class FSharpUtils:
    """Stub for Newtonsoft.Json.Utilities.FSharpUtils"""
    def __init__(self) -> None: ...
    Instance: typing.ClassVar[typing.Any]
    @property
    def FSharpCoreAssembly(self) -> typing.Any: ...
    @property
    def IsUnion(self) -> typing.Any: ...
    @property
    def GetUnionCases(self) -> typing.Any: ...
    @property
    def PreComputeUnionTagReader(self) -> typing.Any: ...
    @property
    def PreComputeUnionReader(self) -> typing.Any: ...
    @property
    def PreComputeUnionConstructor(self) -> typing.Any: ...
    @property
    def GetUnionCaseInfoDeclaringType(self) -> typing.Any: ...
    @property
    def GetUnionCaseInfoName(self) -> typing.Any: ...
    @property
    def GetUnionCaseInfoTag(self) -> typing.Any: ...
    @property
    def GetUnionCaseInfoFields(self) -> typing.Any: ...
    FSharpSetTypeName: typing.ClassVar[str]
    FSharpListTypeName: typing.ClassVar[str]
    FSharpMapTypeName: typing.ClassVar[str]
    def BuildMapCreator(self) -> typing.Any: ...
    def CreateMap(self, keyType: typing.Any, valueType: typing.Any) -> typing.Any: ...
    def CreateSeq(self, t: typing.Any) -> typing.Any: ...
    @classmethod
    def EnsureInitialized(cls, fsharpCoreAssembly: typing.Any) -> None: ...

class Fallback(MulticastDelegate):
    """Stub for Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1+Fallback"""
    def __init__(self, object: typing.Any, method: typing.Any) -> None: ...
    def BeginInvoke(self, errorSuggestion: typing.Any, callback: typing.Any, object: typing.Any) -> typing.Any: ...
    def EndInvoke(self, result: typing.Any) -> typing.Any: ...
    def Invoke(self, errorSuggestion: typing.Any) -> typing.Any: ...

class GetBinderAdapter(GetMemberBinder):
    """Stub for Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1+GetBinderAdapter"""
    def __init__(self) -> None: ...
    def FallbackGetMember(self, target: typing.Any, errorSuggestion: typing.Any) -> typing.Any: ...

class ILGeneratorExtensions:
    """Stub for Newtonsoft.Json.Utilities.ILGeneratorExtensions"""
    def __init__(self) -> None: ...
    @classmethod
    def BoxIfNeeded(cls, generator: typing.Any, type: typing.Any) -> None: ...
    @classmethod
    def CallMethod(cls, generator: typing.Any, methodInfo: typing.Any) -> None: ...
    @classmethod
    def PushArrayInstance(cls, generator: typing.Any, argsIndex: int, arrayIndex: int) -> None: ...
    @classmethod
    def PushInstance(cls, generator: typing.Any, type: typing.Any) -> None: ...
    @classmethod
    def Return(cls, generator: typing.Any) -> None: ...
    @classmethod
    def UnboxIfNeeded(cls, generator: typing.Any, type: typing.Any) -> None: ...

class IWrappedCollection:
    """Stub for Newtonsoft.Json.Utilities.IWrappedCollection"""
    def __init__(self) -> None: ...
    @property
    def UnderlyingCollection(self) -> typing.Any: ...

class IWrappedDictionary:
    """Stub for Newtonsoft.Json.Utilities.IWrappedDictionary"""
    def __init__(self) -> None: ...
    @property
    def UnderlyingDictionary(self) -> typing.Any: ...

class ImmutableCollectionTypeInfo:
    """Stub for Newtonsoft.Json.Utilities.ImmutableCollectionsUtils+ImmutableCollectionTypeInfo"""
    def __init__(self, contractTypeName: str, createdTypeName: str, builderTypeName: str) -> None: ...
    @property
    def ContractTypeName(self) -> str: ...
    @property
    def CreatedTypeName(self) -> str: ...
    @property
    def BuilderTypeName(self) -> str: ...

class ImmutableCollectionsUtils:
    """Stub for Newtonsoft.Json.Utilities.ImmutableCollectionsUtils"""
    def __init__(self) -> None: ...

class JavaScriptUtils:
    """Stub for Newtonsoft.Json.Utilities.JavaScriptUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def GetCharEscapeFlags(cls, stringEscapeHandling: int, quoteChar: str) -> typing.Sequence[bool]: ...
    @classmethod
    def ShouldEscapeJavaScriptString(cls, s: str, charEscapeFlags: typing.Sequence[bool]) -> bool: ...
    @classmethod
    def ToEscapedJavaScriptString(cls, value: str, delimiter: str, appendDelimiters: bool, stringEscapeHandling: int) -> str: ...
    @classmethod
    def TryGetDateFromConstructorJson(cls, reader: typing.Any, dateTime: typing.Any, errorMessage: typing.Any) -> bool: ...
    @classmethod
    def WriteCharAsync(cls, task: typing.Awaitable[None], writer: typing.Any, c: str, cancellationToken: typing.Any) -> typing.Awaitable[None]: ...
    @classmethod
    def WriteEscapedJavaScriptString(cls, writer: typing.Any, s: str, delimiter: str, appendDelimiters: bool, charEscapeFlags: typing.Sequence[bool], stringEscapeHandling: int, bufferPool: typing.Any, writeBuffer: typing.Any) -> None: ...
    @classmethod
    def WriteEscapedJavaScriptStringAsync(cls, writer: typing.Any, s: str, delimiter: str, appendDelimiters: bool, charEscapeFlags: typing.Sequence[bool], stringEscapeHandling: int, client: typing.Any, writeBuffer: typing.Sequence[str], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...

class JsonTokenUtils:
    """Stub for Newtonsoft.Json.Utilities.JsonTokenUtils"""
    def __init__(self) -> None: ...

class LateBoundReflectionDelegateFactory(ReflectionDelegateFactory):
    """Stub for Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory"""
    def __init__(self) -> None: ...
    def CreateDefaultConstructor(self, type: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, propertyInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, fieldInfo: typing.Any) -> typing.Any: ...
    def CreateMethodCall(self, method: typing.Any) -> typing.Any: ...
    def CreateParameterizedConstructor(self, method: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, fieldInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, propertyInfo: typing.Any) -> typing.Any: ...

class MathUtils:
    """Stub for Newtonsoft.Json.Utilities.MathUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def ApproxEquals(cls, d1: float, d2: float) -> bool: ...
    @classmethod
    def IntLength(cls, i: int) -> int: ...
    @classmethod
    def IntToHex(cls, n: int) -> str: ...
    @typing.overload
    @classmethod
    def Max(cls, val1: typing.Optional[int], val2: typing.Optional[int]) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def Max(cls, val1: typing.Optional[float], val2: typing.Optional[float]) -> typing.Optional[float]: ...
    @classmethod
    def Min(cls, val1: typing.Optional[int], val2: typing.Optional[int]) -> typing.Optional[int]: ...

class MiscellaneousUtils:
    """Stub for Newtonsoft.Json.Utilities.MiscellaneousUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def Assert(cls, condition: bool, message: str | None = None) -> None: ...
    @classmethod
    def ByteArrayCompare(cls, a1: typing.Sequence[int], a2: typing.Sequence[int]) -> int: ...
    @classmethod
    def CreateArgumentOutOfRangeException(cls, paramName: str, actualValue: typing.Any, message: str) -> typing.Any: ...
    @classmethod
    def GetLocalName(cls, qualifiedName: str) -> str: ...
    @classmethod
    def GetPrefix(cls, qualifiedName: str) -> str: ...
    @classmethod
    def GetQualifiedNameParts(cls, qualifiedName: str, prefix: typing.Any, localName: typing.Any) -> None: ...
    @classmethod
    def ToString(cls, value: typing.Any) -> str: ...
    @classmethod
    def ValueEquals(cls, objA: typing.Any, objB: typing.Any) -> bool: ...

class NoThrowExpressionVisitor(ExpressionVisitor):
    """Stub for Newtonsoft.Json.Utilities.NoThrowExpressionVisitor"""
    def __init__(self) -> None: ...

class NoThrowGetBinderMember(GetMemberBinder):
    """Stub for Newtonsoft.Json.Utilities.NoThrowGetBinderMember"""
    def __init__(self, innerBinder: typing.Any) -> None: ...
    def FallbackGetMember(self, target: typing.Any, errorSuggestion: typing.Any) -> typing.Any: ...

class NoThrowSetBinderMember(SetMemberBinder):
    """Stub for Newtonsoft.Json.Utilities.NoThrowSetBinderMember"""
    def __init__(self, innerBinder: typing.Any) -> None: ...
    def FallbackSetMember(self, target: typing.Any, value: typing.Any, errorSuggestion: typing.Any) -> typing.Any: ...

class ParseResult(enum.IntEnum):
    None_: int = 0
    Success: int = 1
    Overflow: int = 2
    Invalid: int = 3

class ParserTimeZone(enum.IntEnum):
    Unspecified: int = 0
    Utc: int = 1
    LocalWestOfUtc: int = 2
    LocalEastOfUtc: int = 3

class PrimitiveTypeCode(enum.IntEnum):
    Empty: int = 0
    Object: int = 1
    Char: int = 2
    CharNullable: int = 3
    Boolean: int = 4
    BooleanNullable: int = 5
    SByte: int = 6
    SByteNullable: int = 7
    Int16: int = 8
    Int16Nullable: int = 9
    UInt16: int = 10
    UInt16Nullable: int = 11
    Int32: int = 12
    Int32Nullable: int = 13
    Byte: int = 14
    ByteNullable: int = 15
    UInt32: int = 16
    UInt32Nullable: int = 17
    Int64: int = 18
    Int64Nullable: int = 19
    UInt64: int = 20
    UInt64Nullable: int = 21
    Single: int = 22
    SingleNullable: int = 23
    Double: int = 24
    DoubleNullable: int = 25
    DateTime: int = 26
    DateTimeNullable: int = 27
    DateTimeOffset: int = 28
    DateTimeOffsetNullable: int = 29
    Decimal: int = 30
    DecimalNullable: int = 31
    Guid: int = 32
    GuidNullable: int = 33
    TimeSpan: int = 34
    TimeSpanNullable: int = 35
    BigInteger: int = 36
    BigIntegerNullable: int = 37
    Uri: int = 38
    String: int = 39
    Bytes: int = 40
    DBNull: int = 41

class ReflectionDelegateFactory:
    """Stub for Newtonsoft.Json.Utilities.ReflectionDelegateFactory"""
    def __init__(self) -> None: ...
    def CreateDefaultConstructor(self, type: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, memberInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, propertyInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateGet(self, fieldInfo: typing.Any) -> typing.Any: ...
    def CreateMethodCall(self, method: typing.Any) -> typing.Any: ...
    def CreateParameterizedConstructor(self, method: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, memberInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, fieldInfo: typing.Any) -> typing.Any: ...
    @typing.overload
    def CreateSet(self, propertyInfo: typing.Any) -> typing.Any: ...

class ReflectionMember:
    """Stub for Newtonsoft.Json.Utilities.ReflectionMember"""
    def __init__(self) -> None: ...
    @property
    def MemberType(self) -> typing.Any: ...
    @property
    def Getter(self) -> typing.Any: ...
    @property
    def Setter(self) -> typing.Any: ...

class ReflectionObject:
    """Stub for Newtonsoft.Json.Utilities.ReflectionObject"""
    def __init__(self) -> None: ...
    @property
    def Creator(self) -> typing.Any: ...
    @property
    def Members(self) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Create(cls, t: typing.Any, memberNames: typing.Sequence[str]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Create(cls, t: typing.Any, creator: typing.Any, memberNames: typing.Sequence[str]) -> typing.Any: ...
    def GetType(self, member: str) -> typing.Any: ...
    def GetValue(self, target: typing.Any, member: str) -> typing.Any: ...
    def SetValue(self, target: typing.Any, member: str, value: typing.Any) -> None: ...

class ReflectionUtils:
    """Stub for Newtonsoft.Json.Utilities.ReflectionUtils"""
    def __init__(self) -> None: ...
    EmptyTypes: typing.ClassVar[typing.Sequence[typing.Any]]
    @classmethod
    def CanReadMemberValue(cls, member: typing.Any, nonPublic: bool) -> bool: ...
    @classmethod
    def CanSetMemberValue(cls, member: typing.Any, nonPublic: bool, canSetReadOnly: bool) -> bool: ...
    @classmethod
    def EnsureNotByRefType(cls, t: typing.Any) -> typing.Any: ...
    @classmethod
    def EnsureNotNullableType(cls, t: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def GetAttribute(cls, attributeProvider: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def GetAttribute(cls, attributeProvider: typing.Any, inherit: bool) -> typing.Any: ...
    @typing.overload
    @classmethod
    def GetAttributes(cls, attributeProvider: typing.Any, inherit: bool) -> typing.Sequence[typing.Any]: ...
    @typing.overload
    @classmethod
    def GetAttributes(cls, attributeProvider: typing.Any, attributeType: typing.Any, inherit: bool) -> typing.Sequence[typing.Any]: ...
    @classmethod
    def GetBaseDefinition(cls, propertyInfo: typing.Any) -> typing.Any: ...
    @classmethod
    def GetCollectionItemType(cls, type: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def GetDefaultConstructor(cls, t: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def GetDefaultConstructor(cls, t: typing.Any, nonPublic: bool) -> typing.Any: ...
    @classmethod
    def GetDefaultValue(cls, type: typing.Any) -> typing.Any: ...
    @classmethod
    def GetDictionaryKeyValueTypes(cls, dictionaryType: typing.Any, keyType: typing.Any, valueType: typing.Any) -> None: ...
    @classmethod
    def GetFields(cls, targetType: typing.Any, bindingAttr: int) -> typing.Iterable[typing.Any]: ...
    @classmethod
    def GetFieldsAndProperties(cls, type: typing.Any, bindingAttr: int) -> list[typing.Any]: ...
    @classmethod
    def GetMemberInfoFromType(cls, targetType: typing.Any, memberInfo: typing.Any) -> typing.Any: ...
    @classmethod
    def GetMemberUnderlyingType(cls, member: typing.Any) -> typing.Any: ...
    @classmethod
    def GetMemberValue(cls, member: typing.Any, target: typing.Any) -> typing.Any: ...
    @classmethod
    def GetObjectType(cls, v: typing.Any) -> typing.Any: ...
    @classmethod
    def GetProperties(cls, targetType: typing.Any, bindingAttr: int) -> typing.Iterable[typing.Any]: ...
    @classmethod
    def GetTypeName(cls, t: typing.Any, assemblyFormat: int, binder: typing.Any) -> str: ...
    @classmethod
    def HasDefaultConstructor(cls, t: typing.Any, nonPublic: bool) -> bool: ...
    @typing.overload
    @classmethod
    def ImplementsGenericDefinition(cls, type: typing.Any, genericInterfaceDefinition: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def ImplementsGenericDefinition(cls, type: typing.Any, genericInterfaceDefinition: typing.Any, implementingType: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def InheritsGenericDefinition(cls, type: typing.Any, genericClassDefinition: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def InheritsGenericDefinition(cls, type: typing.Any, genericClassDefinition: typing.Any, implementingType: typing.Any) -> bool: ...
    @classmethod
    def IsByRefLikeType(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsGenericDefinition(cls, type: typing.Any, genericInterfaceDefinition: typing.Any) -> bool: ...
    @classmethod
    def IsIndexedProperty(cls, property: typing.Any) -> bool: ...
    @classmethod
    def IsMethodOverridden(cls, currentType: typing.Any, methodDeclaringType: typing.Any, method: str) -> bool: ...
    @classmethod
    def IsNullable(cls, t: typing.Any) -> bool: ...
    @classmethod
    def IsNullableType(cls, t: typing.Any) -> bool: ...
    @classmethod
    def IsPublic(cls, property: typing.Any) -> bool: ...
    @classmethod
    def IsVirtual(cls, propertyInfo: typing.Any) -> bool: ...
    @classmethod
    def RemoveFlag(cls, bindingAttr: int, flag: int) -> int: ...
    @classmethod
    def SetMemberValue(cls, member: typing.Any, target: typing.Any, value: typing.Any) -> None: ...
    @classmethod
    def SplitFullyQualifiedTypeName(cls, fullyQualifiedTypeName: str) -> typing.Any: ...

class SeparatedCaseState(enum.IntEnum):
    Start: int = 0
    Lower: int = 1
    Upper: int = 2
    NewWord: int = 3

class StringBuffer(ValueType):
    """Stub for Newtonsoft.Json.Utilities.StringBuffer"""
    def __init__(self, bufferPool: typing.Any, initalSize: int) -> None: ...
    @property
    def Position(self) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def InternalBuffer(self) -> typing.Sequence[str]: ...
    @typing.overload
    def Append(self, bufferPool: typing.Any, value: str) -> None: ...
    @typing.overload
    def Append(self, bufferPool: typing.Any, buffer: typing.Sequence[str], startIndex: int, count: int) -> None: ...
    def Clear(self, bufferPool: typing.Any) -> None: ...
    @typing.overload
    def ToString(self) -> str: ...
    @typing.overload
    def ToString(self, start: int, length: int) -> str: ...

class StringReference(ValueType):
    """Stub for Newtonsoft.Json.Utilities.StringReference"""
    def __init__(self, chars: typing.Sequence[str], startIndex: int, length: int) -> None: ...
    @property
    def Item(self) -> str: ...
    @property
    def Chars(self) -> typing.Sequence[str]: ...
    @property
    def StartIndex(self) -> int: ...
    @property
    def Length(self) -> int: ...
    def ToString(self) -> str: ...

class StringReferenceExtensions:
    """Stub for Newtonsoft.Json.Utilities.StringReferenceExtensions"""
    def __init__(self) -> None: ...
    @classmethod
    def EndsWith(cls, s: typing.Any, text: str) -> bool: ...
    @classmethod
    def IndexOf(cls, s: typing.Any, c: str, startIndex: int, length: int) -> int: ...
    @classmethod
    def StartsWith(cls, s: typing.Any, text: str) -> bool: ...

class StringUtils:
    """Stub for Newtonsoft.Json.Utilities.StringUtils"""
    def __init__(self) -> None: ...
    CarriageReturnLineFeed: typing.ClassVar[str]
    Empty: typing.ClassVar[str]
    CarriageReturn: typing.ClassVar[str]
    LineFeed: typing.ClassVar[str]
    Tab: typing.ClassVar[str]
    @classmethod
    def CreateStringWriter(cls, capacity: int) -> typing.Any: ...
    @classmethod
    def EndsWith(cls, source: str, value: str) -> bool: ...
    @classmethod
    def ForgivingCaseSensitiveFind(cls, source: typing.Iterable[typing.Any], valueSelector: typing.Any, testValue: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def FormatWith(cls, format: str, provider: typing.Any, arg0: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def FormatWith(cls, format: str, provider: typing.Any, arg0: typing.Any, arg1: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def FormatWith(cls, format: str, provider: typing.Any, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def FormatWith(cls, format: str, provider: typing.Any, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any, arg3: typing.Any) -> str: ...
    @classmethod
    def IsHighSurrogate(cls, c: str) -> bool: ...
    @classmethod
    def IsLowSurrogate(cls, c: str) -> bool: ...
    @classmethod
    def IsNullOrEmpty(cls, value: str) -> bool: ...
    @classmethod
    def IsWhiteSpace(cls, s: str) -> bool: ...
    @classmethod
    def StartsWith(cls, source: str, value: str) -> bool: ...
    @classmethod
    def ToCamelCase(cls, s: str) -> str: ...
    @classmethod
    def ToCharAsUnicode(cls, c: str, buffer: typing.Sequence[str]) -> None: ...
    @classmethod
    def ToKebabCase(cls, s: str) -> str: ...
    @classmethod
    def ToSnakeCase(cls, s: str) -> str: ...
    @classmethod
    def Trim(cls, s: str, start: int, length: int) -> str: ...

class TypeExtensions:
    """Stub for Newtonsoft.Json.Utilities.TypeExtensions"""
    def __init__(self) -> None: ...
    @classmethod
    def Assembly(cls, type: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def AssignableToTypeName(cls, type: typing.Any, fullTypeName: str, searchInterfaces: bool, match: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def AssignableToTypeName(cls, type: typing.Any, fullTypeName: str, searchInterfaces: bool) -> bool: ...
    @classmethod
    def BaseType(cls, type: typing.Any) -> typing.Any: ...
    @classmethod
    def ContainsGenericParameters(cls, type: typing.Any) -> bool: ...
    @classmethod
    def ImplementInterface(cls, type: typing.Any, interfaceType: typing.Any) -> bool: ...
    @classmethod
    def IsAbstract(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsClass(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsEnum(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsGenericType(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsGenericTypeDefinition(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsInterface(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsPrimitive(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsSealed(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsValueType(cls, type: typing.Any) -> bool: ...
    @classmethod
    def IsVisible(cls, type: typing.Any) -> bool: ...
    @classmethod
    def MemberType(cls, memberInfo: typing.Any) -> int: ...
    @classmethod
    def Method(cls, d: typing.Any) -> typing.Any: ...

class TypeInformation:
    """Stub for Newtonsoft.Json.Utilities.TypeInformation"""
    def __init__(self, type: typing.Any, typeCode: int) -> None: ...
    @property
    def Type(self) -> typing.Any: ...
    @property
    def TypeCode(self) -> int: ...

class ValidationUtils:
    """Stub for Newtonsoft.Json.Utilities.ValidationUtils"""
    def __init__(self) -> None: ...
    @classmethod
    def ArgumentNotNull(cls, value: typing.Any, parameterName: str) -> None: ...

__all__ = [
    'AsyncUtils',
    'Base64Encoder',
    'BinderWrapper',
    'BufferUtils',
    'ByRefParameter',
    'CollectionUtils',
    'ConvertResult',
    'ConvertUtils',
    'DateTimeParser',
    'DateTimeUtils',
    'DynamicReflectionDelegateFactory',
    'DynamicUtils',
    'EnumInfo',
    'EnumUtils',
    'ExpressionReflectionDelegateFactory',
    'FSharpFunction',
    'FSharpUtils',
    'Fallback',
    'GetBinderAdapter',
    'ILGeneratorExtensions',
    'IWrappedCollection',
    'IWrappedDictionary',
    'ImmutableCollectionTypeInfo',
    'ImmutableCollectionsUtils',
    'JavaScriptUtils',
    'JsonTokenUtils',
    'LateBoundReflectionDelegateFactory',
    'MathUtils',
    'MiscellaneousUtils',
    'NoThrowExpressionVisitor',
    'NoThrowGetBinderMember',
    'NoThrowSetBinderMember',
    'ParseResult',
    'ParserTimeZone',
    'PrimitiveTypeCode',
    'ReflectionDelegateFactory',
    'ReflectionMember',
    'ReflectionObject',
    'ReflectionUtils',
    'SeparatedCaseState',
    'StringBuffer',
    'StringReference',
    'StringReferenceExtensions',
    'StringUtils',
    'TypeExtensions',
    'TypeInformation',
    'ValidationUtils',
]
