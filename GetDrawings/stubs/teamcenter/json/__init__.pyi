# This file is auto-generated by generate_tc_stubs.py
# Type hints only â€“ improves VS Code/Pylance & Codex suggestions.
from __future__ import annotations
import typing
import enum
# stub package
from teamcenter.newtonsoft.json import JsonContainerAttribute
from teamcenter.newtonsoft.json import JsonException
from teamcenter.newtonsoft.json import JsonNameTable
from teamcenter.newtonsoft.json import JsonReader
from teamcenter.newtonsoft.json import JsonWriter
from teamcenter.system import Attribute
from teamcenter.system import Exception
from teamcenter.system import ValueType

class ConstructorHandling(enum.IntEnum):
    Default: int = 0
    AllowNonPublicDefaultConstructor: int = 1

class DateFormatHandling(enum.IntEnum):
    IsoDateFormat: int = 0
    MicrosoftDateFormat: int = 1

class DateParseHandling(enum.IntEnum):
    None_: int = 0
    DateTime: int = 1
    DateTimeOffset: int = 2

class DateTimeZoneHandling(enum.IntEnum):
    Local: int = 0
    Utc: int = 1
    Unspecified: int = 2
    RoundtripKind: int = 3

class DefaultJsonNameTable(JsonNameTable):
    """Stub for Newtonsoft.Json.DefaultJsonNameTable"""
    def __init__(self) -> None: ...
    def Add(self, key: str) -> str: ...
    def Get(self, key: typing.Sequence[str], start: int, length: int) -> str: ...

class DefaultValueHandling(enum.IntEnum):
    Include: int = 0
    Ignore: int = 1
    Populate: int = 2
    IgnoreAndPopulate: int = 3

class Entry:
    """Stub for Newtonsoft.Json.DefaultJsonNameTable+Entry"""
    def __init__(self) -> None: ...

class FloatFormatHandling(enum.IntEnum):
    String: int = 0
    Symbol: int = 1
    DefaultValue: int = 2

class FloatParseHandling(enum.IntEnum):
    Double: int = 0
    Decimal: int = 1

class Formatting(enum.IntEnum):
    None_: int = 0
    Indented: int = 1

class IJsonLineInfo:
    """Stub for Newtonsoft.Json.IJsonLineInfo"""
    def __init__(self) -> None: ...
    @property
    def LineNumber(self) -> int: ...
    @property
    def LinePosition(self) -> int: ...
    def HasLineInfo(self) -> bool: ...

class JsonArrayAttribute(JsonContainerAttribute):
    """Stub for Newtonsoft.Json.JsonArrayAttribute"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, allowNullItems: bool) -> None: ...
    @typing.overload
    def __init__(self, id: str) -> None: ...
    @property
    def AllowNullItems(self) -> bool: ...

class JsonConstructorAttribute(Attribute):
    """Stub for Newtonsoft.Json.JsonConstructorAttribute"""
    def __init__(self) -> None: ...

class JsonContainerAttribute(Attribute):
    """Stub for Newtonsoft.Json.JsonContainerAttribute"""
    def __init__(self) -> None: ...
    @property
    def Id(self) -> str: ...
    @property
    def Title(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @property
    def ItemConverterType(self) -> typing.Any: ...
    @property
    def ItemConverterParameters(self) -> typing.Sequence[typing.Any]: ...
    @property
    def NamingStrategyType(self) -> typing.Any: ...
    @property
    def NamingStrategyParameters(self) -> typing.Sequence[typing.Any]: ...
    @property
    def IsReference(self) -> bool: ...
    @property
    def ItemIsReference(self) -> bool: ...
    @property
    def ItemReferenceLoopHandling(self) -> int: ...
    @property
    def ItemTypeNameHandling(self) -> int: ...

class JsonContainerType(enum.IntEnum):
    None_: int = 0
    Object: int = 1
    Array: int = 2
    Constructor: int = 3

class JsonConvert:
    """Stub for Newtonsoft.Json.JsonConvert"""
    def __init__(self) -> None: ...
    DefaultSettings: typing.ClassVar[typing.Any]
    True_: typing.ClassVar[str]
    False_: typing.ClassVar[str]
    Null: typing.ClassVar[str]
    Undefined: typing.ClassVar[str]
    PositiveInfinity: typing.ClassVar[str]
    NegativeInfinity: typing.ClassVar[str]
    NaN: typing.ClassVar[str]
    @typing.overload
    @classmethod
    def DeserializeAnonymousType(cls, value: str, anonymousTypeObject: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeAnonymousType(cls, value: str, anonymousTypeObject: typing.Any, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeObject(cls, value: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeObject(cls, value: str, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeObject(cls, value: str, type: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeObject(cls, value: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeObject(cls, value: str, converters: typing.Sequence[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeObject(cls, value: str, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeObject(cls, value: str, type: typing.Any, converters: typing.Sequence[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeObject(cls, value: str, type: typing.Any, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeXNode(cls, value: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeXNode(cls, value: str, deserializeRootElementName: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeXNode(cls, value: str, deserializeRootElementName: str, writeArrayAttribute: bool) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeXNode(cls, value: str, deserializeRootElementName: str, writeArrayAttribute: bool, encodeSpecialCharacters: bool) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeXmlNode(cls, value: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeXmlNode(cls, value: str, deserializeRootElementName: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeXmlNode(cls, value: str, deserializeRootElementName: str, writeArrayAttribute: bool) -> typing.Any: ...
    @typing.overload
    @classmethod
    def DeserializeXmlNode(cls, value: str, deserializeRootElementName: str, writeArrayAttribute: bool, encodeSpecialCharacters: bool) -> typing.Any: ...
    @typing.overload
    @classmethod
    def PopulateObject(cls, value: str, target: typing.Any) -> None: ...
    @typing.overload
    @classmethod
    def PopulateObject(cls, value: str, target: typing.Any, settings: typing.Any) -> None: ...
    @typing.overload
    @classmethod
    def SerializeObject(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def SerializeObject(cls, value: typing.Any, formatting: int) -> str: ...
    @typing.overload
    @classmethod
    def SerializeObject(cls, value: typing.Any, converters: typing.Sequence[typing.Any]) -> str: ...
    @typing.overload
    @classmethod
    def SerializeObject(cls, value: typing.Any, formatting: int, converters: typing.Sequence[typing.Any]) -> str: ...
    @typing.overload
    @classmethod
    def SerializeObject(cls, value: typing.Any, settings: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def SerializeObject(cls, value: typing.Any, type: typing.Any, settings: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def SerializeObject(cls, value: typing.Any, formatting: int, settings: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def SerializeObject(cls, value: typing.Any, type: typing.Any, formatting: int, settings: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def SerializeXNode(cls, node: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def SerializeXNode(cls, node: typing.Any, formatting: int) -> str: ...
    @typing.overload
    @classmethod
    def SerializeXNode(cls, node: typing.Any, formatting: int, omitRootObject: bool) -> str: ...
    @typing.overload
    @classmethod
    def SerializeXmlNode(cls, node: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def SerializeXmlNode(cls, node: typing.Any, formatting: int) -> str: ...
    @typing.overload
    @classmethod
    def SerializeXmlNode(cls, node: typing.Any, formatting: int, omitRootObject: bool) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any, format: int, timeZoneHandling: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any, format: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: bool) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: str) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: float) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: float) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: float) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: str) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: str, delimiter: str) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: str, delimiter: str, stringEscapeHandling: int) -> str: ...
    @typing.overload
    @classmethod
    def ToString(cls, value: typing.Any) -> str: ...

class JsonConverter:
    """Stub for Newtonsoft.Json.JsonConverter"""
    def __init__(self) -> None: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    def CanConvert(self, objectType: typing.Any) -> bool: ...
    def ReadJson(self, reader: typing.Any, objectType: typing.Any, existingValue: typing.Any, serializer: typing.Any) -> typing.Any: ...
    def WriteJson(self, writer: typing.Any, value: typing.Any, serializer: typing.Any) -> None: ...

class JsonConverterAttribute(Attribute):
    """Stub for Newtonsoft.Json.JsonConverterAttribute"""
    @typing.overload
    def __init__(self, converterType: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, converterType: typing.Any, converterParameters: typing.Sequence[typing.Any]) -> None: ...
    @property
    def ConverterType(self) -> typing.Any: ...
    @property
    def ConverterParameters(self) -> typing.Sequence[typing.Any]: ...

class JsonConverterCollection(object):
    """Stub for Newtonsoft.Json.JsonConverterCollection"""
    def __init__(self) -> None: ...

class JsonDictionaryAttribute(JsonContainerAttribute):
    """Stub for Newtonsoft.Json.JsonDictionaryAttribute"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, id: str) -> None: ...

class JsonException(Exception):
    """Stub for Newtonsoft.Json.JsonException"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, info: typing.Any, context: typing.Any) -> None: ...

class JsonExtensionDataAttribute(Attribute):
    """Stub for Newtonsoft.Json.JsonExtensionDataAttribute"""
    def __init__(self) -> None: ...
    @property
    def WriteData(self) -> bool: ...
    @property
    def ReadData(self) -> bool: ...

class JsonIgnoreAttribute(Attribute):
    """Stub for Newtonsoft.Json.JsonIgnoreAttribute"""
    def __init__(self) -> None: ...

class JsonNameTable:
    """Stub for Newtonsoft.Json.JsonNameTable"""
    def __init__(self) -> None: ...
    def Get(self, key: typing.Sequence[str], start: int, length: int) -> str: ...

class JsonObjectAttribute(JsonContainerAttribute):
    """Stub for Newtonsoft.Json.JsonObjectAttribute"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, memberSerialization: int) -> None: ...
    @typing.overload
    def __init__(self, id: str) -> None: ...
    @property
    def MemberSerialization(self) -> int: ...
    @property
    def MissingMemberHandling(self) -> int: ...
    @property
    def ItemNullValueHandling(self) -> int: ...
    @property
    def ItemRequired(self) -> int: ...

class JsonPosition(ValueType):
    """Stub for Newtonsoft.Json.JsonPosition"""
    def __init__(self, type: int) -> None: ...

class JsonPropertyAttribute(Attribute):
    """Stub for Newtonsoft.Json.JsonPropertyAttribute"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, propertyName: str) -> None: ...
    @property
    def ItemConverterType(self) -> typing.Any: ...
    @property
    def ItemConverterParameters(self) -> typing.Sequence[typing.Any]: ...
    @property
    def NamingStrategyType(self) -> typing.Any: ...
    @property
    def NamingStrategyParameters(self) -> typing.Sequence[typing.Any]: ...
    @property
    def NullValueHandling(self) -> int: ...
    @property
    def DefaultValueHandling(self) -> int: ...
    @property
    def ReferenceLoopHandling(self) -> int: ...
    @property
    def ObjectCreationHandling(self) -> int: ...
    @property
    def TypeNameHandling(self) -> int: ...
    @property
    def IsReference(self) -> bool: ...
    @property
    def Order(self) -> int: ...
    @property
    def Required(self) -> int: ...
    @property
    def PropertyName(self) -> str: ...
    @property
    def ItemReferenceLoopHandling(self) -> int: ...
    @property
    def ItemTypeNameHandling(self) -> int: ...
    @property
    def ItemIsReference(self) -> bool: ...

class JsonReader:
    """Stub for Newtonsoft.Json.JsonReader"""
    def __init__(self) -> None: ...
    @property
    def CloseInput(self) -> bool: ...
    @property
    def SupportMultipleContent(self) -> bool: ...
    @property
    def QuoteChar(self) -> str: ...
    @property
    def DateTimeZoneHandling(self) -> int: ...
    @property
    def DateParseHandling(self) -> int: ...
    @property
    def FloatParseHandling(self) -> int: ...
    @property
    def DateFormatString(self) -> str: ...
    @property
    def MaxDepth(self) -> typing.Optional[int]: ...
    @property
    def TokenType(self) -> int: ...
    @property
    def Value(self) -> typing.Any: ...
    @property
    def ValueType(self) -> typing.Any: ...
    @property
    def Depth(self) -> int: ...
    @property
    def Path(self) -> str: ...
    @property
    def Culture(self) -> typing.Any: ...
    def Close(self) -> None: ...
    def Read(self) -> bool: ...
    def ReadAsBoolean(self) -> typing.Optional[bool]: ...
    def ReadAsBooleanAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[bool]]: ...
    def ReadAsBytes(self) -> typing.Sequence[int]: ...
    def ReadAsBytesAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Sequence[int]]: ...
    def ReadAsDateTime(self) -> typing.Optional[typing.Any]: ...
    def ReadAsDateTimeAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[typing.Any]]: ...
    def ReadAsDateTimeOffset(self) -> typing.Optional[typing.Any]: ...
    def ReadAsDateTimeOffsetAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[typing.Any]]: ...
    def ReadAsDecimal(self) -> typing.Optional[float]: ...
    def ReadAsDecimalAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[float]]: ...
    def ReadAsDouble(self) -> typing.Optional[float]: ...
    def ReadAsDoubleAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[float]]: ...
    def ReadAsInt32(self) -> typing.Optional[int]: ...
    def ReadAsInt32Async(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[int]]: ...
    def ReadAsString(self) -> str: ...
    def ReadAsStringAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[str]: ...
    def ReadAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[bool]: ...
    def Skip(self) -> None: ...
    def SkipAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...

class JsonReaderException(JsonException):
    """Stub for Newtonsoft.Json.JsonReaderException"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, info: typing.Any, context: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, message: str, path: str, lineNumber: int, linePosition: int, innerException: typing.Any) -> None: ...
    @property
    def LineNumber(self) -> int: ...
    @property
    def LinePosition(self) -> int: ...
    @property
    def Path(self) -> str: ...

class JsonRequiredAttribute(Attribute):
    """Stub for Newtonsoft.Json.JsonRequiredAttribute"""
    def __init__(self) -> None: ...

class JsonSerializationException(JsonException):
    """Stub for Newtonsoft.Json.JsonSerializationException"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, info: typing.Any, context: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, message: str, path: str, lineNumber: int, linePosition: int, innerException: typing.Any) -> None: ...
    @property
    def LineNumber(self) -> int: ...
    @property
    def LinePosition(self) -> int: ...
    @property
    def Path(self) -> str: ...

class JsonSerializer:
    """Stub for Newtonsoft.Json.JsonSerializer"""
    def __init__(self) -> None: ...
    @property
    def ReferenceResolver(self) -> typing.Any: ...
    @property
    def Binder(self) -> typing.Any: ...
    @property
    def SerializationBinder(self) -> typing.Any: ...
    @property
    def TraceWriter(self) -> typing.Any: ...
    @property
    def EqualityComparer(self) -> typing.Any: ...
    @property
    def TypeNameHandling(self) -> int: ...
    @property
    def TypeNameAssemblyFormat(self) -> int: ...
    @property
    def TypeNameAssemblyFormatHandling(self) -> int: ...
    @property
    def PreserveReferencesHandling(self) -> int: ...
    @property
    def ReferenceLoopHandling(self) -> int: ...
    @property
    def MissingMemberHandling(self) -> int: ...
    @property
    def NullValueHandling(self) -> int: ...
    @property
    def DefaultValueHandling(self) -> int: ...
    @property
    def ObjectCreationHandling(self) -> int: ...
    @property
    def ConstructorHandling(self) -> int: ...
    @property
    def MetadataPropertyHandling(self) -> int: ...
    @property
    def Converters(self) -> typing.Any: ...
    @property
    def ContractResolver(self) -> typing.Any: ...
    @property
    def Context(self) -> typing.Any: ...
    @property
    def Formatting(self) -> int: ...
    @property
    def DateFormatHandling(self) -> int: ...
    @property
    def DateTimeZoneHandling(self) -> int: ...
    @property
    def DateParseHandling(self) -> int: ...
    @property
    def FloatParseHandling(self) -> int: ...
    @property
    def FloatFormatHandling(self) -> int: ...
    @property
    def StringEscapeHandling(self) -> int: ...
    @property
    def DateFormatString(self) -> str: ...
    @property
    def Culture(self) -> typing.Any: ...
    @property
    def MaxDepth(self) -> typing.Optional[int]: ...
    @property
    def CheckAdditionalContent(self) -> bool: ...
    @typing.overload
    @classmethod
    def Create(cls) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Create(cls, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def CreateDefault(cls) -> typing.Any: ...
    @typing.overload
    @classmethod
    def CreateDefault(cls, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    def Deserialize(self, reader: typing.Any) -> typing.Any: ...
    @typing.overload
    def Deserialize(self, reader: typing.Any, objectType: typing.Any) -> typing.Any: ...
    @typing.overload
    def Deserialize(self, reader: typing.Any) -> typing.Any: ...
    @typing.overload
    def Deserialize(self, reader: typing.Any, objectType: typing.Any) -> typing.Any: ...
    @typing.overload
    def Populate(self, reader: typing.Any, target: typing.Any) -> None: ...
    @typing.overload
    def Populate(self, reader: typing.Any, target: typing.Any) -> None: ...
    @typing.overload
    def Serialize(self, textWriter: typing.Any, value: typing.Any) -> None: ...
    @typing.overload
    def Serialize(self, jsonWriter: typing.Any, value: typing.Any, objectType: typing.Any) -> None: ...
    @typing.overload
    def Serialize(self, textWriter: typing.Any, value: typing.Any, objectType: typing.Any) -> None: ...
    @typing.overload
    def Serialize(self, jsonWriter: typing.Any, value: typing.Any) -> None: ...

class JsonSerializerSettings:
    """Stub for Newtonsoft.Json.JsonSerializerSettings"""
    def __init__(self) -> None: ...
    @property
    def ReferenceLoopHandling(self) -> int: ...
    @property
    def MissingMemberHandling(self) -> int: ...
    @property
    def ObjectCreationHandling(self) -> int: ...
    @property
    def NullValueHandling(self) -> int: ...
    @property
    def DefaultValueHandling(self) -> int: ...
    @property
    def Converters(self) -> typing.Sequence[typing.Any]: ...
    @property
    def PreserveReferencesHandling(self) -> int: ...
    @property
    def TypeNameHandling(self) -> int: ...
    @property
    def MetadataPropertyHandling(self) -> int: ...
    @property
    def TypeNameAssemblyFormat(self) -> int: ...
    @property
    def TypeNameAssemblyFormatHandling(self) -> int: ...
    @property
    def ConstructorHandling(self) -> int: ...
    @property
    def ContractResolver(self) -> typing.Any: ...
    @property
    def EqualityComparer(self) -> typing.Any: ...
    @property
    def ReferenceResolver(self) -> typing.Any: ...
    @property
    def ReferenceResolverProvider(self) -> typing.Any: ...
    @property
    def TraceWriter(self) -> typing.Any: ...
    @property
    def Binder(self) -> typing.Any: ...
    @property
    def SerializationBinder(self) -> typing.Any: ...
    @property
    def Error(self) -> typing.Any: ...
    @property
    def Context(self) -> typing.Any: ...
    @property
    def DateFormatString(self) -> str: ...
    @property
    def MaxDepth(self) -> typing.Optional[int]: ...
    @property
    def Formatting(self) -> int: ...
    @property
    def DateFormatHandling(self) -> int: ...
    @property
    def DateTimeZoneHandling(self) -> int: ...
    @property
    def DateParseHandling(self) -> int: ...
    @property
    def FloatFormatHandling(self) -> int: ...
    @property
    def FloatParseHandling(self) -> int: ...
    @property
    def StringEscapeHandling(self) -> int: ...
    @property
    def Culture(self) -> typing.Any: ...
    @property
    def CheckAdditionalContent(self) -> bool: ...

class JsonTextReader(JsonReader):
    """Stub for Newtonsoft.Json.JsonTextReader"""
    def __init__(self, reader: typing.Any) -> None: ...
    @property
    def PropertyNameTable(self) -> typing.Any: ...
    @property
    def ArrayPool(self) -> typing.Any: ...
    @property
    def LineNumber(self) -> int: ...
    @property
    def LinePosition(self) -> int: ...
    def Close(self) -> None: ...
    def HasLineInfo(self) -> bool: ...
    def Read(self) -> bool: ...
    def ReadAsBoolean(self) -> typing.Optional[bool]: ...
    def ReadAsBooleanAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[bool]]: ...
    def ReadAsBytes(self) -> typing.Sequence[int]: ...
    def ReadAsBytesAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Sequence[int]]: ...
    def ReadAsDateTime(self) -> typing.Optional[typing.Any]: ...
    def ReadAsDateTimeAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[typing.Any]]: ...
    def ReadAsDateTimeOffset(self) -> typing.Optional[typing.Any]: ...
    def ReadAsDateTimeOffsetAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[typing.Any]]: ...
    def ReadAsDecimal(self) -> typing.Optional[float]: ...
    def ReadAsDecimalAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[float]]: ...
    def ReadAsDouble(self) -> typing.Optional[float]: ...
    def ReadAsDoubleAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[float]]: ...
    def ReadAsInt32(self) -> typing.Optional[int]: ...
    def ReadAsInt32Async(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Optional[int]]: ...
    def ReadAsString(self) -> str: ...
    def ReadAsStringAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[str]: ...
    def ReadAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[bool]: ...

class JsonTextWriter(JsonWriter):
    """Stub for Newtonsoft.Json.JsonTextWriter"""
    def __init__(self, textWriter: typing.Any) -> None: ...
    @property
    def ArrayPool(self) -> typing.Any: ...
    @property
    def Indentation(self) -> int: ...
    @property
    def QuoteChar(self) -> str: ...
    @property
    def IndentChar(self) -> str: ...
    @property
    def QuoteName(self) -> bool: ...
    def Close(self) -> None: ...
    def CloseAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteComment(self, text: str) -> None: ...
    def WriteCommentAsync(self, text: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteEndArrayAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteEndAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteEndConstructorAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteEndObjectAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteNull(self) -> None: ...
    def WriteNullAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WritePropertyName(self, name: str) -> None: ...
    @typing.overload
    def WritePropertyName(self, name: str, escape: bool) -> None: ...
    @typing.overload
    def WritePropertyNameAsync(self, name: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WritePropertyNameAsync(self, name: str, escape: bool, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteRaw(self, json: str) -> None: ...
    def WriteRawAsync(self, json: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteRawValueAsync(self, json: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteStartArray(self) -> None: ...
    def WriteStartArrayAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteStartConstructor(self, name: str) -> None: ...
    def WriteStartConstructorAsync(self, name: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteStartObject(self) -> None: ...
    def WriteStartObjectAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteUndefined(self) -> None: ...
    def WriteUndefinedAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: str) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[float]) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[float]) -> None: ...
    @typing.overload
    def WriteValue(self, value: bool) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: str) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Sequence[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValueAsync(self, value: bool, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[bool], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Sequence[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[str], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[typing.Any], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[typing.Any], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: float, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[float], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: float, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[float], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: float, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[float], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[typing.Any], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[typing.Any], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteWhitespace(self, ws: str) -> None: ...
    def WriteWhitespaceAsync(self, ws: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...

class JsonToken(enum.IntEnum):
    None_: int = 0
    StartObject: int = 1
    StartArray: int = 2
    StartConstructor: int = 3
    PropertyName: int = 4
    Comment: int = 5
    Raw: int = 6
    Integer: int = 7
    Float: int = 8
    String: int = 9
    Boolean: int = 10
    Null: int = 11
    Undefined: int = 12
    EndObject: int = 13
    EndArray: int = 14
    EndConstructor: int = 15
    Date: int = 16
    Bytes: int = 17

class JsonValidatingReader(JsonReader):
    """Stub for Newtonsoft.Json.JsonValidatingReader"""
    def __init__(self, reader: typing.Any) -> None: ...
    @property
    def Value(self) -> typing.Any: ...
    @property
    def Depth(self) -> int: ...
    @property
    def Path(self) -> str: ...
    @property
    def QuoteChar(self) -> str: ...
    @property
    def TokenType(self) -> int: ...
    @property
    def ValueType(self) -> typing.Any: ...
    @property
    def Schema(self) -> typing.Any: ...
    @property
    def Reader(self) -> typing.Any: ...
    def Close(self) -> None: ...
    def Read(self) -> bool: ...
    def ReadAsBoolean(self) -> typing.Optional[bool]: ...
    def ReadAsBytes(self) -> typing.Sequence[int]: ...
    def ReadAsDateTime(self) -> typing.Optional[typing.Any]: ...
    def ReadAsDateTimeOffset(self) -> typing.Optional[typing.Any]: ...
    def ReadAsDecimal(self) -> typing.Optional[float]: ...
    def ReadAsDouble(self) -> typing.Optional[float]: ...
    def ReadAsInt32(self) -> typing.Optional[int]: ...
    def ReadAsString(self) -> str: ...

class JsonWriter:
    """Stub for Newtonsoft.Json.JsonWriter"""
    def __init__(self) -> None: ...
    @property
    def CloseOutput(self) -> bool: ...
    @property
    def AutoCompleteOnClose(self) -> bool: ...
    @property
    def WriteState(self) -> int: ...
    @property
    def Path(self) -> str: ...
    @property
    def Formatting(self) -> int: ...
    @property
    def DateFormatHandling(self) -> int: ...
    @property
    def DateTimeZoneHandling(self) -> int: ...
    @property
    def StringEscapeHandling(self) -> int: ...
    @property
    def FloatFormatHandling(self) -> int: ...
    @property
    def DateFormatString(self) -> str: ...
    @property
    def Culture(self) -> typing.Any: ...
    def Close(self) -> None: ...
    def CloseAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteComment(self, text: str) -> None: ...
    def WriteCommentAsync(self, text: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteEnd(self) -> None: ...
    def WriteEndArray(self) -> None: ...
    def WriteEndArrayAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteEndAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteEndConstructor(self) -> None: ...
    def WriteEndConstructorAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteEndObject(self) -> None: ...
    def WriteEndObjectAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteNull(self) -> None: ...
    def WriteNullAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WritePropertyName(self, name: str) -> None: ...
    @typing.overload
    def WritePropertyName(self, name: str, escape: bool) -> None: ...
    @typing.overload
    def WritePropertyNameAsync(self, name: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WritePropertyNameAsync(self, name: str, escape: bool, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteRaw(self, json: str) -> None: ...
    def WriteRawAsync(self, json: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteRawValue(self, json: str) -> None: ...
    def WriteRawValueAsync(self, json: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteStartArray(self) -> None: ...
    def WriteStartArrayAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteStartConstructor(self, name: str) -> None: ...
    def WriteStartConstructorAsync(self, name: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteStartObject(self) -> None: ...
    def WriteStartObjectAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteToken(self, reader: typing.Any) -> None: ...
    @typing.overload
    def WriteToken(self, reader: typing.Any, writeChildren: bool) -> None: ...
    @typing.overload
    def WriteToken(self, token: int, value: typing.Any) -> None: ...
    @typing.overload
    def WriteToken(self, token: int) -> None: ...
    @typing.overload
    def WriteTokenAsync(self, reader: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteTokenAsync(self, reader: typing.Any, writeChildren: bool, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteTokenAsync(self, token: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteTokenAsync(self, token: int, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteUndefined(self) -> None: ...
    def WriteUndefinedAsync(self, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValue(self, value: str) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: bool) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: str) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[float]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[float]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[bool]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[str]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[float]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[typing.Any]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[typing.Any]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[typing.Any]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Optional[typing.Any]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Sequence[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValueAsync(self, value: bool, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[bool], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Sequence[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[str], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[typing.Any], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[typing.Any], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: float, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[float], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: float, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[float], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: float, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[float], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[typing.Any], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[typing.Any], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: int, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteValueAsync(self, value: typing.Optional[int], cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...
    def WriteWhitespace(self, ws: str) -> None: ...
    def WriteWhitespaceAsync(self, ws: str, cancellationToken: typing.Any | None = None) -> typing.Awaitable[None]: ...

class JsonWriterException(JsonException):
    """Stub for Newtonsoft.Json.JsonWriterException"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, info: typing.Any, context: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, message: str, path: str, innerException: typing.Any) -> None: ...
    @property
    def Path(self) -> str: ...

class MemberSerialization(enum.IntEnum):
    OptOut: int = 0
    OptIn: int = 1
    Fields: int = 2

class MetadataPropertyHandling(enum.IntEnum):
    Default: int = 0
    ReadAhead: int = 1
    Ignore: int = 2

class MissingMemberHandling(enum.IntEnum):
    Ignore: int = 0
    Error: int = 1

class NullValueHandling(enum.IntEnum):
    Include: int = 0
    Ignore: int = 1

class ObjectCreationHandling(enum.IntEnum):
    Auto: int = 0
    Reuse: int = 1
    Replace: int = 2

class PreserveReferencesHandling(enum.IntEnum):
    None_: int = 0
    Objects: int = 1
    Arrays: int = 2
    All: int = 3

class ReadType(enum.IntEnum):
    Read: int = 0
    ReadAsInt32: int = 1
    ReadAsInt64: int = 2
    ReadAsBytes: int = 3
    ReadAsString: int = 4
    ReadAsDecimal: int = 5
    ReadAsDateTime: int = 6
    ReadAsDateTimeOffset: int = 7
    ReadAsDouble: int = 8
    ReadAsBoolean: int = 9

class ReferenceLoopHandling(enum.IntEnum):
    Error: int = 0
    Ignore: int = 1
    Serialize: int = 2

class Required(enum.IntEnum):
    Default: int = 0
    AllowNull: int = 1
    Always: int = 2
    DisallowNull: int = 3

class SchemaScope:
    """Stub for Newtonsoft.Json.JsonValidatingReader+SchemaScope"""
    def __init__(self, tokenType: int, schemas: typing.Sequence[typing.Any]) -> None: ...
    @property
    def CurrentPropertyName(self) -> str: ...
    @property
    def ArrayItemCount(self) -> int: ...
    @property
    def IsUniqueArray(self) -> bool: ...
    @property
    def UniqueArrayItems(self) -> typing.Sequence[typing.Any]: ...
    @property
    def CurrentItemWriter(self) -> typing.Any: ...
    @property
    def Schemas(self) -> typing.Sequence[typing.Any]: ...
    @property
    def RequiredProperties(self) -> dict[str, bool]: ...
    @property
    def TokenType(self) -> int: ...

class State(enum.IntEnum):
    Start: int = 0
    Complete: int = 1
    Property: int = 2
    ObjectStart: int = 3
    Object: int = 4
    ArrayStart: int = 5
    Array: int = 6
    Closed: int = 7
    PostValue: int = 8
    ConstructorStart: int = 9
    Constructor: int = 10
    Error: int = 11
    Finished: int = 12

class State(enum.IntEnum):
    Start: int = 0
    Property: int = 1
    ObjectStart: int = 2
    Object: int = 3
    ArrayStart: int = 4
    Array: int = 5
    ConstructorStart: int = 6
    Constructor: int = 7
    Closed: int = 8
    Error: int = 9

class StringEscapeHandling(enum.IntEnum):
    Default: int = 0
    EscapeNonAscii: int = 1
    EscapeHtml: int = 2

class TypeNameAssemblyFormatHandling(enum.IntEnum):
    Simple: int = 0
    Full: int = 1

class TypeNameHandling(enum.IntEnum):
    None_: int = 0
    Objects: int = 1
    Arrays: int = 2
    All: int = 3
    Auto: int = 4

class WriteState(enum.IntEnum):
    Error: int = 0
    Closed: int = 1
    Object: int = 2
    Array: int = 3
    Constructor: int = 4
    Property: int = 5
    Start: int = 6

__all__ = [
    'ConstructorHandling',
    'DateFormatHandling',
    'DateParseHandling',
    'DateTimeZoneHandling',
    'DefaultJsonNameTable',
    'DefaultValueHandling',
    'Entry',
    'FloatFormatHandling',
    'FloatParseHandling',
    'Formatting',
    'IJsonLineInfo',
    'JsonArrayAttribute',
    'JsonConstructorAttribute',
    'JsonContainerAttribute',
    'JsonContainerType',
    'JsonConvert',
    'JsonConverter',
    'JsonConverterAttribute',
    'JsonConverterCollection',
    'JsonDictionaryAttribute',
    'JsonException',
    'JsonExtensionDataAttribute',
    'JsonIgnoreAttribute',
    'JsonNameTable',
    'JsonObjectAttribute',
    'JsonPosition',
    'JsonPropertyAttribute',
    'JsonReader',
    'JsonReaderException',
    'JsonRequiredAttribute',
    'JsonSerializationException',
    'JsonSerializer',
    'JsonSerializerSettings',
    'JsonTextReader',
    'JsonTextWriter',
    'JsonToken',
    'JsonValidatingReader',
    'JsonWriter',
    'JsonWriterException',
    'MemberSerialization',
    'MetadataPropertyHandling',
    'MissingMemberHandling',
    'NullValueHandling',
    'ObjectCreationHandling',
    'PreserveReferencesHandling',
    'ReadType',
    'ReferenceLoopHandling',
    'Required',
    'SchemaScope',
    'State',
    'StringEscapeHandling',
    'TypeNameAssemblyFormatHandling',
    'TypeNameHandling',
    'WriteState',
    'bson',
    'converters',
    'linq',
    'schema',
    'serialization',
    'utilities',
]
