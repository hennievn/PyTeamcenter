# This file is auto-generated by generate_tc_stubs.py
# Type hints only â€“ improves VS Code/Pylance & Codex suggestions.
from __future__ import annotations
import typing
import enum
# stub package
from teamcenter.newtonsoft.json.linq.jsonpath import PathFilter
from teamcenter.newtonsoft.json.linq.jsonpath import QueryExpression

class ArrayIndexFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter"""
    def __init__(self) -> None: ...
    @property
    def Index(self) -> typing.Optional[int]: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class ArrayMultipleIndexFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter"""
    def __init__(self, indexes: list[int]) -> None: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class ArraySliceFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter"""
    def __init__(self) -> None: ...
    @property
    def Start(self) -> typing.Optional[int]: ...
    @property
    def End(self) -> typing.Optional[int]: ...
    @property
    def Step(self) -> typing.Optional[int]: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class BooleanQueryExpression(QueryExpression):
    """Stub for Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression"""
    def __init__(self, operator: int, left: typing.Any, right: typing.Any) -> None: ...
    Left: typing.Any
    Right: typing.Any
    def IsMatch(self, root: typing.Any, t: typing.Any, settings: typing.Any) -> bool: ...

class CompositeExpression(QueryExpression):
    """Stub for Newtonsoft.Json.Linq.JsonPath.CompositeExpression"""
    def __init__(self, operator: int) -> None: ...
    @property
    def Expressions(self) -> list[typing.Any]: ...
    def IsMatch(self, root: typing.Any, t: typing.Any, settings: typing.Any) -> bool: ...

class FieldFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.FieldFilter"""
    def __init__(self, name: str) -> None: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class FieldMultipleFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter"""
    def __init__(self, names: list[str]) -> None: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class JPath:
    """Stub for Newtonsoft.Json.Linq.JsonPath.JPath"""
    def __init__(self, expression: str) -> None: ...
    @property
    def Filters(self) -> list[typing.Any]: ...

class PathFilter:
    """Stub for Newtonsoft.Json.Linq.JsonPath.PathFilter"""
    def __init__(self) -> None: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class QueryExpression:
    """Stub for Newtonsoft.Json.Linq.JsonPath.QueryExpression"""
    def __init__(self, operator: int) -> None: ...
    @typing.overload
    def IsMatch(self, root: typing.Any, t: typing.Any) -> bool: ...
    @typing.overload
    def IsMatch(self, root: typing.Any, t: typing.Any, settings: typing.Any) -> bool: ...

class QueryFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.QueryFilter"""
    def __init__(self, expression: typing.Any) -> None: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class QueryOperator(enum.IntEnum):
    None_: int = 0
    Equals: int = 1
    NotEquals: int = 2
    Exists: int = 3
    LessThan: int = 4
    LessThanOrEquals: int = 5
    GreaterThan: int = 6
    GreaterThanOrEquals: int = 7
    And: int = 8
    Or: int = 9
    RegexEquals: int = 10
    StrictEquals: int = 11
    StrictNotEquals: int = 12

class QueryScanFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.QueryScanFilter"""
    def __init__(self, expression: typing.Any) -> None: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class RootFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.RootFilter"""
    def __init__(self) -> None: ...
    Instance: typing.ClassVar[typing.Any]
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class ScanFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.ScanFilter"""
    def __init__(self, name: str) -> None: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

class ScanMultipleFilter(PathFilter):
    """Stub for Newtonsoft.Json.Linq.JsonPath.ScanMultipleFilter"""
    def __init__(self, names: list[str]) -> None: ...
    def ExecuteFilter(self, root: typing.Any, current: typing.Iterable[typing.Any], settings: typing.Any) -> typing.Iterable[typing.Any]: ...

__all__ = [
    'ArrayIndexFilter',
    'ArrayMultipleIndexFilter',
    'ArraySliceFilter',
    'BooleanQueryExpression',
    'CompositeExpression',
    'FieldFilter',
    'FieldMultipleFilter',
    'JPath',
    'PathFilter',
    'QueryExpression',
    'QueryFilter',
    'QueryOperator',
    'QueryScanFilter',
    'RootFilter',
    'ScanFilter',
    'ScanMultipleFilter',
]
