# This file is auto-generated by generate_tc_stubs.py
# Type hints only â€“ improves VS Code/Pylance & Codex suggestions.
from __future__ import annotations
import typing
import enum
# stub package
from teamcenter.newtonsoft.json import JsonReader
from teamcenter.newtonsoft.json import JsonWriter
from teamcenter.newtonsoft.json.linq import JContainer
from teamcenter.newtonsoft.json.linq import JToken
from teamcenter.newtonsoft.json.linq import JValue
from teamcenter.system.componentmodel import PropertyDescriptor

class CommentHandling(enum.IntEnum):
    Ignore: int = 0
    Load: int = 1

class DuplicatePropertyNameHandling(enum.IntEnum):
    Replace: int = 0
    Ignore: int = 1
    Error: int = 2

class Extensions:
    """Stub for Newtonsoft.Json.Linq.Extensions"""
    def __init__(self) -> None: ...
    @classmethod
    def Ancestors(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @classmethod
    def AncestorsAndSelf(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def AsJEnumerable(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def AsJEnumerable(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Children(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Children(cls, source: typing.Iterable[typing.Any]) -> typing.Iterable[typing.Any]: ...
    @classmethod
    def Descendants(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @classmethod
    def DescendantsAndSelf(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @classmethod
    def Properties(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Value(cls, value: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Value(cls, value: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Values(cls, source: typing.Iterable[typing.Any], key: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Values(cls, source: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Values(cls, source: typing.Iterable[typing.Any], key: typing.Any) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    @classmethod
    def Values(cls, source: typing.Iterable[typing.Any]) -> typing.Iterable[typing.Any]: ...

class JArray(JContainer):
    """Stub for Newtonsoft.Json.Linq.JArray"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, other: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, content: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, content: typing.Any) -> None: ...
    @property
    def Type(self) -> int: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def IsReadOnly(self) -> bool: ...
    def Add(self, item: typing.Any) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: typing.Any) -> bool: ...
    def CopyTo(self, array: typing.Sequence[typing.Any], arrayIndex: int) -> None: ...
    @typing.overload
    @classmethod
    def FromObject(cls, o: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def FromObject(cls, o: typing.Any, jsonSerializer: typing.Any) -> typing.Any: ...
    def GetEnumerator(self) -> typing.Any: ...
    def IndexOf(self, item: typing.Any) -> int: ...
    def Insert(self, index: int, item: typing.Any) -> None: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, settings: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def Parse(cls, json: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Parse(cls, json: str, settings: typing.Any) -> typing.Any: ...
    def Remove(self, item: typing.Any) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    def WriteTo(self, writer: typing.Any, converters: typing.Sequence[typing.Any]) -> None: ...
    def WriteToAsync(self, writer: typing.Any, cancellationToken: typing.Any, converters: typing.Sequence[typing.Any]) -> typing.Awaitable[None]: ...

class JConstructor(JContainer):
    """Stub for Newtonsoft.Json.Linq.JConstructor"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, other: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @property
    def Name(self) -> str: ...
    @property
    def Type(self) -> int: ...
    @property
    def Item(self) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, settings: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    def WriteTo(self, writer: typing.Any, converters: typing.Sequence[typing.Any]) -> None: ...
    def WriteToAsync(self, writer: typing.Any, cancellationToken: typing.Any, converters: typing.Sequence[typing.Any]) -> typing.Awaitable[None]: ...

class JContainer(JToken):
    """Stub for Newtonsoft.Json.Linq.JContainer"""
    def __init__(self) -> None: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def First(self) -> typing.Any: ...
    @property
    def Last(self) -> typing.Any: ...
    @property
    def Count(self) -> int: ...
    def Add(self, content: typing.Any) -> None: ...
    def AddFirst(self, content: typing.Any) -> None: ...
    def Children(self) -> typing.Any: ...
    def CreateWriter(self) -> typing.Any: ...
    def Descendants(self) -> typing.Iterable[typing.Any]: ...
    def DescendantsAndSelf(self) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    def Merge(self, content: typing.Any) -> None: ...
    @typing.overload
    def Merge(self, content: typing.Any, settings: typing.Any) -> None: ...
    def RemoveAll(self) -> None: ...
    def ReplaceAll(self, content: typing.Any) -> None: ...
    def Values(self) -> typing.Iterable[typing.Any]: ...

class JObject(JContainer):
    """Stub for Newtonsoft.Json.Linq.JObject"""
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, other: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, content: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, content: typing.Any) -> None: ...
    @property
    def Type(self) -> int: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    def Add(self, propertyName: str, value: typing.Any) -> None: ...
    def ContainsKey(self, propertyName: str) -> bool: ...
    @typing.overload
    @classmethod
    def FromObject(cls, o: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def FromObject(cls, o: typing.Any, jsonSerializer: typing.Any) -> typing.Any: ...
    def GetEnumerator(self) -> typing.Any: ...
    @typing.overload
    def GetValue(self, propertyName: str) -> typing.Any: ...
    @typing.overload
    def GetValue(self, propertyName: str, comparison: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, settings: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def Parse(cls, json: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Parse(cls, json: str, settings: typing.Any) -> typing.Any: ...
    def Properties(self) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    def Property(self, name: str) -> typing.Any: ...
    @typing.overload
    def Property(self, name: str, comparison: int) -> typing.Any: ...
    def PropertyValues(self) -> typing.Any: ...
    def Remove(self, propertyName: str) -> bool: ...
    @typing.overload
    def TryGetValue(self, propertyName: str, comparison: int, value: typing.Any) -> bool: ...
    @typing.overload
    def TryGetValue(self, propertyName: str, value: typing.Any) -> bool: ...
    def WriteTo(self, writer: typing.Any, converters: typing.Sequence[typing.Any]) -> None: ...
    def WriteToAsync(self, writer: typing.Any, cancellationToken: typing.Any, converters: typing.Sequence[typing.Any]) -> typing.Awaitable[None]: ...

class JObjectDynamicProxy(object):
    """Stub for Newtonsoft.Json.Linq.JObject+JObjectDynamicProxy"""
    def __init__(self) -> None: ...
    def GetDynamicMemberNames(self, instance: typing.Any) -> typing.Iterable[str]: ...
    def TryGetMember(self, instance: typing.Any, binder: typing.Any, result: typing.Any) -> bool: ...
    def TrySetMember(self, instance: typing.Any, binder: typing.Any, value: typing.Any) -> bool: ...

class JProperty(JContainer):
    """Stub for Newtonsoft.Json.Linq.JProperty"""
    @typing.overload
    def __init__(self, other: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: typing.Any) -> None: ...
    @property
    def Name(self) -> str: ...
    @property
    def Value(self) -> typing.Any: ...
    @property
    def Type(self) -> int: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, settings: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    def WriteTo(self, writer: typing.Any, converters: typing.Sequence[typing.Any]) -> None: ...
    def WriteToAsync(self, writer: typing.Any, cancellationToken: typing.Any, converters: typing.Sequence[typing.Any]) -> typing.Awaitable[None]: ...

class JPropertyDescriptor(PropertyDescriptor):
    """Stub for Newtonsoft.Json.Linq.JPropertyDescriptor"""
    def __init__(self, name: str) -> None: ...
    @property
    def ComponentType(self) -> typing.Any: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def PropertyType(self) -> typing.Any: ...
    def CanResetValue(self, component: typing.Any) -> bool: ...
    def GetValue(self, component: typing.Any) -> typing.Any: ...
    def ResetValue(self, component: typing.Any) -> None: ...
    def SetValue(self, component: typing.Any, value: typing.Any) -> None: ...
    def ShouldSerializeValue(self, component: typing.Any) -> bool: ...

class JPropertyKeyedCollection(object):
    """Stub for Newtonsoft.Json.Linq.JPropertyKeyedCollection"""
    def __init__(self) -> None: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Keys(self) -> typing.Any: ...
    @property
    def Values(self) -> typing.Any: ...
    def Compare(self, other: typing.Any) -> bool: ...
    def Contains(self, key: str) -> bool: ...
    def IndexOfReference(self, t: typing.Any) -> int: ...
    def Remove(self, key: str) -> bool: ...
    def TryGetValue(self, key: str, value: typing.Any) -> bool: ...

class JPropertyList:
    """Stub for Newtonsoft.Json.Linq.JProperty+JPropertyList"""
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    def Add(self, item: typing.Any) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: typing.Any) -> bool: ...
    def CopyTo(self, array: typing.Sequence[typing.Any], arrayIndex: int) -> None: ...
    def GetEnumerator(self) -> typing.Any: ...
    def IndexOf(self, item: typing.Any) -> int: ...
    def Insert(self, index: int, item: typing.Any) -> None: ...
    def Remove(self, item: typing.Any) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...

class JRaw(JValue):
    """Stub for Newtonsoft.Json.Linq.JRaw"""
    @typing.overload
    def __init__(self, other: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, rawJson: typing.Any) -> None: ...
    @classmethod
    def Create(cls, reader: typing.Any) -> typing.Any: ...
    @classmethod
    def CreateAsync(cls, reader: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...

class JToken:
    """Stub for Newtonsoft.Json.Linq.JToken"""
    def __init__(self) -> None: ...
    EqualityComparer: typing.ClassVar[typing.Any]
    @property
    def Parent(self) -> typing.Any: ...
    @property
    def Root(self) -> typing.Any: ...
    @property
    def Type(self) -> int: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Next(self) -> typing.Any: ...
    @property
    def Previous(self) -> typing.Any: ...
    @property
    def Path(self) -> str: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def First(self) -> typing.Any: ...
    @property
    def Last(self) -> typing.Any: ...
    def AddAfterSelf(self, content: typing.Any) -> None: ...
    def AddAnnotation(self, annotation: typing.Any) -> None: ...
    def AddBeforeSelf(self, content: typing.Any) -> None: ...
    def AfterSelf(self) -> typing.Iterable[typing.Any]: ...
    def Ancestors(self) -> typing.Iterable[typing.Any]: ...
    def AncestorsAndSelf(self) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    def Annotation(self) -> typing.Any: ...
    @typing.overload
    def Annotation(self, type: typing.Any) -> typing.Any: ...
    @typing.overload
    def Annotations(self) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    def Annotations(self, type: typing.Any) -> typing.Iterable[typing.Any]: ...
    def BeforeSelf(self) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    def Children(self) -> typing.Any: ...
    @typing.overload
    def Children(self) -> typing.Any: ...
    def CreateReader(self) -> typing.Any: ...
    def DeepClone(self) -> typing.Any: ...
    @classmethod
    def DeepEquals(cls, t1: typing.Any, t2: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def FromObject(cls, o: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def FromObject(cls, o: typing.Any, jsonSerializer: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Load(cls, reader: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def LoadAsync(cls, reader: typing.Any, settings: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def Parse(cls, json: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def Parse(cls, json: str, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def ReadFrom(cls, reader: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def ReadFrom(cls, reader: typing.Any, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def ReadFromAsync(cls, reader: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    @typing.overload
    @classmethod
    def ReadFromAsync(cls, reader: typing.Any, settings: typing.Any, cancellationToken: typing.Any | None = None) -> typing.Awaitable[typing.Any]: ...
    def Remove(self) -> None: ...
    @typing.overload
    def RemoveAnnotations(self) -> None: ...
    @typing.overload
    def RemoveAnnotations(self, type: typing.Any) -> None: ...
    def Replace(self, value: typing.Any) -> None: ...
    @typing.overload
    def SelectToken(self, path: str) -> typing.Any: ...
    @typing.overload
    def SelectToken(self, path: str, errorWhenNoMatch: bool) -> typing.Any: ...
    @typing.overload
    def SelectToken(self, path: str, settings: typing.Any) -> typing.Any: ...
    @typing.overload
    def SelectTokens(self, path: str) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    def SelectTokens(self, path: str, errorWhenNoMatch: bool) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    def SelectTokens(self, path: str, settings: typing.Any) -> typing.Iterable[typing.Any]: ...
    @typing.overload
    def ToObject(self, jsonSerializer: typing.Any) -> typing.Any: ...
    @typing.overload
    def ToObject(self, objectType: typing.Any, jsonSerializer: typing.Any) -> typing.Any: ...
    @typing.overload
    def ToObject(self) -> typing.Any: ...
    @typing.overload
    def ToObject(self, objectType: typing.Any) -> typing.Any: ...
    @typing.overload
    def ToString(self) -> str: ...
    @typing.overload
    def ToString(self, formatting: int, converters: typing.Sequence[typing.Any]) -> str: ...
    def Value(self, key: typing.Any) -> typing.Any: ...
    def Values(self) -> typing.Iterable[typing.Any]: ...
    def WriteTo(self, writer: typing.Any, converters: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def WriteToAsync(self, writer: typing.Any, cancellationToken: typing.Any, converters: typing.Sequence[typing.Any]) -> typing.Awaitable[None]: ...
    @typing.overload
    def WriteToAsync(self, writer: typing.Any, converters: typing.Sequence[typing.Any]) -> typing.Awaitable[None]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> bool: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[bool]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[typing.Any]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[typing.Any]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[float]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[float]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[str]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[float]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> float: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> float: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> float: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> str: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> int: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Sequence[int]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[typing.Any]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Optional[typing.Any]: ...
    @typing.overload
    @classmethod
    def op_Explicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: bool) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[bool]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[float]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[float]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[float]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: float) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: float) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: float) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: str) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: int) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Sequence[int]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[typing.Any]) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Any) -> typing.Any: ...
    @typing.overload
    @classmethod
    def op_Implicit(cls, value: typing.Optional[typing.Any]) -> typing.Any: ...

class JTokenEqualityComparer:
    """Stub for Newtonsoft.Json.Linq.JTokenEqualityComparer"""
    def __init__(self) -> None: ...
    def Equals(self, x: typing.Any, y: typing.Any) -> bool: ...
    def GetHashCode(self, obj: typing.Any) -> int: ...

class JTokenReader(JsonReader):
    """Stub for Newtonsoft.Json.Linq.JTokenReader"""
    @typing.overload
    def __init__(self, token: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, token: typing.Any, initialPath: str) -> None: ...
    @property
    def CurrentToken(self) -> typing.Any: ...
    @property
    def Path(self) -> str: ...
    def Read(self) -> bool: ...

class JTokenType(enum.IntEnum):
    None_: int = 0
    Object: int = 1
    Array: int = 2
    Constructor: int = 3
    Property: int = 4
    Comment: int = 5
    Integer: int = 6
    Float: int = 7
    String: int = 8
    Boolean: int = 9
    Null: int = 10
    Undefined: int = 11
    Date: int = 12
    Raw: int = 13
    Bytes: int = 14
    Guid: int = 15
    Uri: int = 16
    TimeSpan: int = 17

class JTokenWriter(JsonWriter):
    """Stub for Newtonsoft.Json.Linq.JTokenWriter"""
    @typing.overload
    def __init__(self, container: typing.Any) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @property
    def CurrentToken(self) -> typing.Any: ...
    @property
    def Token(self) -> typing.Any: ...
    def Close(self) -> None: ...
    def Flush(self) -> None: ...
    def WriteComment(self, text: str) -> None: ...
    def WriteNull(self) -> None: ...
    def WritePropertyName(self, name: str) -> None: ...
    def WriteRaw(self, json: str) -> None: ...
    def WriteStartArray(self) -> None: ...
    def WriteStartConstructor(self, name: str) -> None: ...
    def WriteStartObject(self) -> None: ...
    def WriteUndefined(self) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: str) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: bool) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: str) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: int) -> None: ...
    @typing.overload
    def WriteValue(self, value: float) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Sequence[int]) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...
    @typing.overload
    def WriteValue(self, value: typing.Any) -> None: ...

class JValue(JToken):
    """Stub for Newtonsoft.Json.Linq.JValue"""
    @typing.overload
    def __init__(self, other: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: float) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: float) -> None: ...
    @typing.overload
    def __init__(self, value: float) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, value: bool) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Type(self) -> int: ...
    @property
    def Value(self) -> typing.Any: ...
    def CompareTo(self, obj: typing.Any) -> int: ...
    @classmethod
    def CreateComment(cls, value: str) -> typing.Any: ...
    @classmethod
    def CreateNull(cls) -> typing.Any: ...
    @classmethod
    def CreateString(cls, value: str) -> typing.Any: ...
    @classmethod
    def CreateUndefined(cls) -> typing.Any: ...
    @typing.overload
    def Equals(self, other: typing.Any) -> bool: ...
    @typing.overload
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @typing.overload
    def ToString(self) -> str: ...
    @typing.overload
    def ToString(self, format: str) -> str: ...
    @typing.overload
    def ToString(self, formatProvider: typing.Any) -> str: ...
    @typing.overload
    def ToString(self, format: str, formatProvider: typing.Any) -> str: ...
    def WriteTo(self, writer: typing.Any, converters: typing.Sequence[typing.Any]) -> None: ...
    def WriteToAsync(self, writer: typing.Any, cancellationToken: typing.Any, converters: typing.Sequence[typing.Any]) -> typing.Awaitable[None]: ...

class JValueDynamicProxy(object):
    """Stub for Newtonsoft.Json.Linq.JValue+JValueDynamicProxy"""
    def __init__(self) -> None: ...
    def TryBinaryOperation(self, instance: typing.Any, binder: typing.Any, arg: typing.Any, result: typing.Any) -> bool: ...
    def TryConvert(self, instance: typing.Any, binder: typing.Any, result: typing.Any) -> bool: ...

class JsonLoadSettings:
    """Stub for Newtonsoft.Json.Linq.JsonLoadSettings"""
    def __init__(self) -> None: ...
    @property
    def CommentHandling(self) -> int: ...
    @property
    def LineInfoHandling(self) -> int: ...
    @property
    def DuplicatePropertyNameHandling(self) -> int: ...

class JsonMergeSettings:
    """Stub for Newtonsoft.Json.Linq.JsonMergeSettings"""
    def __init__(self) -> None: ...
    @property
    def MergeArrayHandling(self) -> int: ...
    @property
    def MergeNullValueHandling(self) -> int: ...
    @property
    def PropertyNameComparison(self) -> int: ...

class JsonSelectSettings:
    """Stub for Newtonsoft.Json.Linq.JsonSelectSettings"""
    def __init__(self) -> None: ...
    @property
    def RegexMatchTimeout(self) -> typing.Optional[typing.Any]: ...
    @property
    def ErrorWhenNoMatch(self) -> bool: ...

class LineInfoAnnotation:
    """Stub for Newtonsoft.Json.Linq.JToken+LineInfoAnnotation"""
    def __init__(self, lineNumber: int, linePosition: int) -> None: ...

class LineInfoHandling(enum.IntEnum):
    Ignore: int = 0
    Load: int = 1

class MergeArrayHandling(enum.IntEnum):
    Concat: int = 0
    Union: int = 1
    Replace: int = 2
    Merge: int = 3

class MergeNullValueHandling(enum.IntEnum):
    Ignore: int = 0
    Merge: int = 1

__all__ = [
    'CommentHandling',
    'DuplicatePropertyNameHandling',
    'Extensions',
    'JArray',
    'JConstructor',
    'JContainer',
    'JObject',
    'JObjectDynamicProxy',
    'JProperty',
    'JPropertyDescriptor',
    'JPropertyKeyedCollection',
    'JPropertyList',
    'JRaw',
    'JToken',
    'JTokenEqualityComparer',
    'JTokenReader',
    'JTokenType',
    'JTokenWriter',
    'JValue',
    'JValueDynamicProxy',
    'JsonLoadSettings',
    'JsonMergeSettings',
    'JsonSelectSettings',
    'LineInfoAnnotation',
    'LineInfoHandling',
    'MergeArrayHandling',
    'MergeNullValueHandling',
    'jsonpath',
]
