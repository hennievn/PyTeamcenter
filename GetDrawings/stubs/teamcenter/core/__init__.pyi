# This file is auto-generated by generate_tc_stubs.py
# Type hints only â€“ improves VS Code/Pylance & Codex suggestions.
from __future__ import annotations
import typing
import enum
# stub package
from teamcenter.system import Attribute
from teamcenter.system import ValueType

class Constants:
    """Stub for Serilog.Core.Constants"""
    def __init__(self) -> None: ...
    SourceContextPropertyName: typing.ClassVar[str]

class IDestructuringPolicy:
    """Stub for Serilog.Core.IDestructuringPolicy"""
    def __init__(self) -> None: ...
    def TryDestructure(self, value: typing.Any, propertyValueFactory: typing.Any, result: typing.Any) -> bool: ...

class ILogEventEnricher:
    """Stub for Serilog.Core.ILogEventEnricher"""
    def __init__(self) -> None: ...
    def Enrich(self, logEvent: typing.Any, propertyFactory: typing.Any) -> None: ...

class ILogEventFilter:
    """Stub for Serilog.Core.ILogEventFilter"""
    def __init__(self) -> None: ...
    def IsEnabled(self, logEvent: typing.Any) -> bool: ...

class ILogEventPropertyFactory:
    """Stub for Serilog.Core.ILogEventPropertyFactory"""
    def __init__(self) -> None: ...
    def CreateProperty(self, name: str, value: typing.Any, destructureObjects: bool | None = None) -> typing.Any: ...

class ILogEventPropertyValueFactory:
    """Stub for Serilog.Core.ILogEventPropertyValueFactory"""
    def __init__(self) -> None: ...
    def CreatePropertyValue(self, value: typing.Any, destructureObjects: bool | None = None) -> typing.Any: ...

class ILogEventSink:
    """Stub for Serilog.Core.ILogEventSink"""
    def __init__(self) -> None: ...
    def Emit(self, logEvent: typing.Any) -> None: ...

class IMessageTemplateParser:
    """Stub for Serilog.Core.IMessageTemplateParser"""
    def __init__(self) -> None: ...
    def Parse(self, messageTemplate: str) -> typing.Any: ...

class IScalarConversionPolicy:
    """Stub for Serilog.Core.IScalarConversionPolicy"""
    def __init__(self) -> None: ...
    def TryConvertToScalar(self, value: typing.Any, result: typing.Any) -> bool: ...

class LevelOverride(ValueType):
    """Stub for Serilog.Core.LevelOverrideMap+LevelOverride"""
    def __init__(self, context: str, levelSwitch: typing.Any) -> None: ...
    @property
    def Context(self) -> str: ...
    @property
    def LevelSwitch(self) -> typing.Any: ...

class LevelOverrideMap:
    """Stub for Serilog.Core.LevelOverrideMap"""
    def __init__(self, overrides: typing.Any, defaultMinimumLevel: int, defaultLevelSwitch: typing.Any) -> None: ...
    def GetEffectiveLevel(self, context: str, minimumLevel: typing.Any, levelSwitch: typing.Any) -> None: ...

class Logger:
    """Stub for Serilog.Core.Logger"""
    def __init__(self) -> None: ...
    None_: typing.ClassVar[typing.Any]
    def BindMessageTemplate(self, messageTemplate: str, propertyValues: typing.Sequence[typing.Any], parsedTemplate: typing.Any, boundProperties: typing.Any) -> bool: ...
    def BindProperty(self, propertyName: str, value: typing.Any, destructureObjects: bool, property: typing.Any) -> bool: ...
    @typing.overload
    def Debug(self, messageTemplate: str) -> None: ...
    @typing.overload
    def Debug(self, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Debug(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Debug(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Debug(self, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Debug(self, exception: typing.Any, messageTemplate: str) -> None: ...
    @typing.overload
    def Debug(self, exception: typing.Any, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Debug(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Debug(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Debug(self, exception: typing.Any, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    def Dispose(self) -> None: ...
    @typing.overload
    def Error(self, messageTemplate: str) -> None: ...
    @typing.overload
    def Error(self, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Error(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Error(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Error(self, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Error(self, exception: typing.Any, messageTemplate: str) -> None: ...
    @typing.overload
    def Error(self, exception: typing.Any, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Error(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Error(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Error(self, exception: typing.Any, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Fatal(self, messageTemplate: str) -> None: ...
    @typing.overload
    def Fatal(self, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Fatal(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Fatal(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Fatal(self, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Fatal(self, exception: typing.Any, messageTemplate: str) -> None: ...
    @typing.overload
    def Fatal(self, exception: typing.Any, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Fatal(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Fatal(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Fatal(self, exception: typing.Any, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def ForContext(self, enricher: typing.Any) -> typing.Any: ...
    @typing.overload
    def ForContext(self, enrichers: typing.Iterable[typing.Any]) -> typing.Any: ...
    @typing.overload
    def ForContext(self, propertyName: str, value: typing.Any, destructureObjects: bool | None = None) -> typing.Any: ...
    @typing.overload
    def ForContext(self, source: typing.Any) -> typing.Any: ...
    @typing.overload
    def ForContext(self) -> typing.Any: ...
    @typing.overload
    def Information(self, messageTemplate: str) -> None: ...
    @typing.overload
    def Information(self, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Information(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Information(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Information(self, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Information(self, exception: typing.Any, messageTemplate: str) -> None: ...
    @typing.overload
    def Information(self, exception: typing.Any, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Information(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Information(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Information(self, exception: typing.Any, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    def IsEnabled(self, level: int) -> bool: ...
    @typing.overload
    def Verbose(self, messageTemplate: str) -> None: ...
    @typing.overload
    def Verbose(self, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Verbose(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Verbose(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Verbose(self, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Verbose(self, exception: typing.Any, messageTemplate: str) -> None: ...
    @typing.overload
    def Verbose(self, exception: typing.Any, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Verbose(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Verbose(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Verbose(self, exception: typing.Any, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Warning(self, messageTemplate: str) -> None: ...
    @typing.overload
    def Warning(self, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Warning(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Warning(self, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Warning(self, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Warning(self, exception: typing.Any, messageTemplate: str) -> None: ...
    @typing.overload
    def Warning(self, exception: typing.Any, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Warning(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Warning(self, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Warning(self, exception: typing.Any, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Write(self, level: int, messageTemplate: str) -> None: ...
    @typing.overload
    def Write(self, level: int, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Write(self, level: int, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Write(self, level: int, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Write(self, level: int, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Write(self, level: int, exception: typing.Any, messageTemplate: str) -> None: ...
    @typing.overload
    def Write(self, level: int, exception: typing.Any, messageTemplate: str, propertyValue: typing.Any) -> None: ...
    @typing.overload
    def Write(self, level: int, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any) -> None: ...
    @typing.overload
    def Write(self, level: int, exception: typing.Any, messageTemplate: str, propertyValue0: typing.Any, propertyValue1: typing.Any, propertyValue2: typing.Any) -> None: ...
    @typing.overload
    def Write(self, level: int, exception: typing.Any, messageTemplate: str, propertyValues: typing.Sequence[typing.Any]) -> None: ...
    @typing.overload
    def Write(self, logEvent: typing.Any) -> None: ...

class LoggingLevelSwitch:
    """Stub for Serilog.Core.LoggingLevelSwitch"""
    def __init__(self, initialMinimumLevel: int | None = None) -> None: ...
    @property
    def MinimumLevel(self) -> int: ...

class MessageTemplateFormatMethodAttribute(Attribute):
    """Stub for Serilog.Core.MessageTemplateFormatMethodAttribute"""
    def __init__(self, messageTemplateParameterName: str) -> None: ...
    @property
    def MessageTemplateParameterName(self) -> str: ...

__all__ = [
    'Constants',
    'IDestructuringPolicy',
    'ILogEventEnricher',
    'ILogEventFilter',
    'ILogEventPropertyFactory',
    'ILogEventPropertyValueFactory',
    'ILogEventSink',
    'IMessageTemplateParser',
    'IScalarConversionPolicy',
    'LevelOverride',
    'LevelOverrideMap',
    'Logger',
    'LoggingLevelSwitch',
    'MessageTemplateFormatMethodAttribute',
    'enrichers',
    'filters',
    'pipeline',
    'sinks',
]
